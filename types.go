// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/trycourier/courier-go/v3/core"
)

type SendMessageRequest struct {
	// Defines the message to be delivered
	Message *Message `json:"message,omitempty" url:"message,omitempty"`
}

type SendMessageResponse struct {
	// A successful call to `POST /send` returns a `202` status code along with a `requestId` in the response body.
	//
	// For send requests that have a single recipient, the `requestId` is assigned to the derived message as its message_id. Therefore the `requestId` can be supplied to the Message's API for single recipient messages.
	//
	// For send requests that have multiple recipients (accounts, audiences, lists, etc.), Courier assigns a unique id to each derived message as its `message_id`. Therefore the `requestId` cannot be supplied to the Message's API for single-recipient messages.
	RequestId string `json:"requestId" url:"requestId"`

	_rawJSON json.RawMessage
}

func (s *SendMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SendMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendMessageResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendMessageResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type AudienceMemberGetResponse struct {
	AudienceMember *AudienceMember `json:"audienceMember,omitempty" url:"audienceMember,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AudienceMemberGetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMemberGetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMemberGetResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMemberGetResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type GetAuditEventParams struct {
	AuditEventId string `json:"auditEventId" url:"auditEventId"`

	_rawJSON json.RawMessage
}

func (g *GetAuditEventParams) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAuditEventParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAuditEventParams(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAuditEventParams) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAuditEventsParams struct {
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListAuditEventsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAuditEventsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAuditEventsParams(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAuditEventsParams) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type AccessorType struct {
	Ref string `json:"$ref" url:"$ref"`

	_rawJSON json.RawMessage
}

func (a *AccessorType) UnmarshalJSON(data []byte) error {
	type unmarshaler AccessorType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccessorType(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccessorType) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationInvokeTemplateParams struct {
	Brand      *string                `json:"brand,omitempty" url:"brand,omitempty"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	Profile    *Profile               `json:"profile,omitempty" url:"profile,omitempty"`
	Recipient  *string                `json:"recipient,omitempty" url:"recipient,omitempty"`
	Template   *string                `json:"template,omitempty" url:"template,omitempty"`
	TemplateId string                 `json:"templateId" url:"templateId"`

	_rawJSON json.RawMessage
}

func (a *AutomationInvokeTemplateParams) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationInvokeTemplateParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationInvokeTemplateParams(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationInvokeTemplateParams) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationRunContext struct {
	Brand     *string     `json:"brand,omitempty" url:"brand,omitempty"`
	Data      interface{} `json:"data,omitempty" url:"data,omitempty"`
	Profile   *Profile    `json:"profile,omitempty" url:"profile,omitempty"`
	Template  *string     `json:"template,omitempty" url:"template,omitempty"`
	Recipient *string     `json:"recipient,omitempty" url:"recipient,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AutomationRunContext) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationRunContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationRunContext(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationRunContext) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BrandGetAllResponse struct {
	Paging  *Paging  `json:"paging,omitempty" url:"paging,omitempty"`
	Results []*Brand `json:"results,omitempty" url:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandGetAllResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandGetAllResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandGetAllResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandGetAllResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkGetJobParams struct {
	JobId string `json:"jobId" url:"jobId"`

	_rawJSON json.RawMessage
}

func (b *BulkGetJobParams) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkGetJobParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkGetJobParams(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkGetJobParams) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkGetJobUsersParams struct {
	JobId  string  `json:"jobId" url:"jobId"`
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkGetJobUsersParams) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkGetJobUsersParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkGetJobUsersParams(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkGetJobUsersParams) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkIngestError struct {
	User  interface{} `json:"user,omitempty" url:"user,omitempty"`
	Error interface{} `json:"error,omitempty" url:"error,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkIngestError) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkIngestError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkIngestError(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkIngestError) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkIngestUsersResponse struct {
	Total  int                `json:"total" url:"total"`
	Errors []*BulkIngestError `json:"errors,omitempty" url:"errors,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkIngestUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkIngestUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkIngestUsersResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkIngestUsersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type AlreadyExists struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (a *AlreadyExists) Type() string {
	return a.type_
}

func (a *AlreadyExists) UnmarshalJSON(data []byte) error {
	type embed AlreadyExists
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AlreadyExists(unmarshaler.embed)
	a.type_ = "invalid_request_error"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlreadyExists) MarshalJSON() ([]byte, error) {
	type embed AlreadyExists
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (a *AlreadyExists) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BadRequest struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (b *BadRequest) Type() string {
	return b.type_
}

func (b *BadRequest) UnmarshalJSON(data []byte) error {
	type embed BadRequest
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BadRequest(unmarshaler.embed)
	b.type_ = "invalid_request_error"
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BadRequest) MarshalJSON() ([]byte, error) {
	type embed BadRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (b *BadRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseError struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`

	_rawJSON json.RawMessage
}

func (b *BaseError) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseError(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseError) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ChannelClassification string

const (
	ChannelClassificationDirectMessage ChannelClassification = "direct_message"
	ChannelClassificationEmail         ChannelClassification = "email"
	ChannelClassificationPush          ChannelClassification = "push"
	ChannelClassificationSms           ChannelClassification = "sms"
	ChannelClassificationWebhook       ChannelClassification = "webhook"
	ChannelClassificationInbox         ChannelClassification = "inbox"
)

func NewChannelClassificationFromString(s string) (ChannelClassification, error) {
	switch s {
	case "direct_message":
		return ChannelClassificationDirectMessage, nil
	case "email":
		return ChannelClassificationEmail, nil
	case "push":
		return ChannelClassificationPush, nil
	case "sms":
		return ChannelClassificationSms, nil
	case "webhook":
		return ChannelClassificationWebhook, nil
	case "inbox":
		return ChannelClassificationInbox, nil
	}
	var t ChannelClassification
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChannelClassification) Ptr() *ChannelClassification {
	return &c
}

type ChannelPreference struct {
	Channel ChannelClassification `json:"channel,omitempty" url:"channel,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChannelPreference) UnmarshalJSON(data []byte) error {
	type unmarshaler ChannelPreference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChannelPreference(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChannelPreference) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Conflict struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (c *Conflict) Type() string {
	return c.type_
}

func (c *Conflict) UnmarshalJSON(data []byte) error {
	type embed Conflict
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Conflict(unmarshaler.embed)
	c.type_ = "invalid_request_error"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Conflict) MarshalJSON() ([]byte, error) {
	type embed Conflict
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (c *Conflict) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type MessageNotFound struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (m *MessageNotFound) Type() string {
	return m.type_
}

func (m *MessageNotFound) UnmarshalJSON(data []byte) error {
	type embed MessageNotFound
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MessageNotFound(unmarshaler.embed)
	m.type_ = "invalid_request_error"
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageNotFound) MarshalJSON() ([]byte, error) {
	type embed MessageNotFound
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (m *MessageNotFound) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NotFound struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (n *NotFound) Type() string {
	return n.type_
}

func (n *NotFound) UnmarshalJSON(data []byte) error {
	type embed NotFound
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotFound(unmarshaler.embed)
	n.type_ = "invalid_request_error"
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotFound) MarshalJSON() ([]byte, error) {
	type embed NotFound
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*n),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (n *NotFound) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPreferenceDetails struct {
	Status             PreferenceStatus     `json:"status,omitempty" url:"status,omitempty"`
	Rules              []*Rule              `json:"rules,omitempty" url:"rules,omitempty"`
	ChannelPreferences []*ChannelPreference `json:"channel_preferences,omitempty" url:"channel_preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotificationPreferenceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPreferenceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPreferenceDetails(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPreferenceDetails) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPreferences = map[string]*NotificationPreferenceDetails

type Paging struct {
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	More   bool    `json:"more" url:"more"`

	_rawJSON json.RawMessage
}

func (p *Paging) UnmarshalJSON(data []byte) error {
	type unmarshaler Paging
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Paging(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Paging) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRequired struct {
	// A message describing the error that occurred.
	Message string `json:"message" url:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (p *PaymentRequired) Type() string {
	return p.type_
}

func (p *PaymentRequired) UnmarshalJSON(data []byte) error {
	type embed PaymentRequired
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentRequired(unmarshaler.embed)
	p.type_ = "authorization_error"
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRequired) MarshalJSON() ([]byte, error) {
	type embed PaymentRequired
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "authorization_error",
	}
	return json.Marshal(marshaler)
}

func (p *PaymentRequired) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PreferenceStatus string

const (
	PreferenceStatusOptedIn  PreferenceStatus = "OPTED_IN"
	PreferenceStatusOptedOut PreferenceStatus = "OPTED_OUT"
	PreferenceStatusRequired PreferenceStatus = "REQUIRED"
)

func NewPreferenceStatusFromString(s string) (PreferenceStatus, error) {
	switch s {
	case "OPTED_IN":
		return PreferenceStatusOptedIn, nil
	case "OPTED_OUT":
		return PreferenceStatusOptedOut, nil
	case "REQUIRED":
		return PreferenceStatusRequired, nil
	}
	var t PreferenceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreferenceStatus) Ptr() *PreferenceStatus {
	return &p
}

type RecipientPreferences struct {
	Categories    *NotificationPreferences `json:"categories,omitempty" url:"categories,omitempty"`
	Notifications *NotificationPreferences `json:"notifications,omitempty" url:"notifications,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecipientPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler RecipientPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecipientPreferences(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecipientPreferences) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Rule struct {
	Start *string `json:"start,omitempty" url:"start,omitempty"`
	Until string  `json:"until" url:"until"`

	_rawJSON json.RawMessage
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	type unmarshaler Rule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Rule(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Rule) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type UserTenantAssociation struct {
	// User ID for the assocation between tenant and user
	UserId *string `json:"user_id,omitempty" url:"user_id,omitempty"`
	Type   *string `json:"type,omitempty" url:"type,omitempty"`
	// Tenant ID for the assocation between tenant and user
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Additional metadata to be applied to a user profile when used in a tenant context
	Profile map[string]interface{} `json:"profile,omitempty" url:"profile,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserTenantAssociation) UnmarshalJSON(data []byte) error {
	type unmarshaler UserTenantAssociation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserTenantAssociation(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserTenantAssociation) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type MessageRouting struct {
	Method   MessageRoutingMethod     `json:"method,omitempty" url:"method,omitempty"`
	Channels []*MessageRoutingChannel `json:"channels,omitempty" url:"channels,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageRouting(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageRouting) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageRoutingChannel struct {
	String         string
	MessageRouting *MessageRouting
}

func (m *MessageRoutingChannel) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.String = valueString
		return nil
	}
	valueMessageRouting := new(MessageRouting)
	if err := json.Unmarshal(data, &valueMessageRouting); err == nil {
		m.MessageRouting = valueMessageRouting
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MessageRoutingChannel) MarshalJSON() ([]byte, error) {
	if m.String != "" {
		return json.Marshal(m.String)
	}
	if m.MessageRouting != nil {
		return json.Marshal(m.MessageRouting)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessageRoutingChannelVisitor interface {
	VisitString(string) error
	VisitMessageRouting(*MessageRouting) error
}

func (m *MessageRoutingChannel) Accept(visitor MessageRoutingChannelVisitor) error {
	if m.String != "" {
		return visitor.VisitString(m.String)
	}
	if m.MessageRouting != nil {
		return visitor.VisitMessageRouting(m.MessageRouting)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessageRoutingMethod string

const (
	MessageRoutingMethodAll    MessageRoutingMethod = "all"
	MessageRoutingMethodSingle MessageRoutingMethod = "single"
)

func NewMessageRoutingMethodFromString(s string) (MessageRoutingMethod, error) {
	switch s {
	case "all":
		return MessageRoutingMethodAll, nil
	case "single":
		return MessageRoutingMethodSingle, nil
	}
	var t MessageRoutingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MessageRoutingMethod) Ptr() *MessageRoutingMethod {
	return &m
}

type Address struct {
	Formatted     string `json:"formatted" url:"formatted"`
	StreetAddress string `json:"street_address" url:"street_address"`
	Locality      string `json:"locality" url:"locality"`
	Region        string `json:"region" url:"region"`
	PostalCode    string `json:"postal_code" url:"postal_code"`
	Country       string `json:"country" url:"country"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AirshipProfile struct {
	Audience    *AirshipProfileAudience `json:"audience,omitempty" url:"audience,omitempty"`
	DeviceTypes []DeviceType            `json:"device_types,omitempty" url:"device_types,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AirshipProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler AirshipProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AirshipProfile(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AirshipProfile) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AirshipProfileAudience struct {
	NamedUser string `json:"named_user" url:"named_user"`

	_rawJSON json.RawMessage
}

func (a *AirshipProfileAudience) UnmarshalJSON(data []byte) error {
	type unmarshaler AirshipProfileAudience
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AirshipProfileAudience(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AirshipProfileAudience) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type DeviceType = interface{}

type Discord struct {
	SendToChannel     *SendToChannel
	SendDirectMessage *SendDirectMessage
}

func (d *Discord) UnmarshalJSON(data []byte) error {
	valueSendToChannel := new(SendToChannel)
	if err := json.Unmarshal(data, &valueSendToChannel); err == nil {
		d.SendToChannel = valueSendToChannel
		return nil
	}
	valueSendDirectMessage := new(SendDirectMessage)
	if err := json.Unmarshal(data, &valueSendDirectMessage); err == nil {
		d.SendDirectMessage = valueSendDirectMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d Discord) MarshalJSON() ([]byte, error) {
	if d.SendToChannel != nil {
		return json.Marshal(d.SendToChannel)
	}
	if d.SendDirectMessage != nil {
		return json.Marshal(d.SendDirectMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DiscordVisitor interface {
	VisitSendToChannel(*SendToChannel) error
	VisitSendDirectMessage(*SendDirectMessage) error
}

func (d *Discord) Accept(visitor DiscordVisitor) error {
	if d.SendToChannel != nil {
		return visitor.VisitSendToChannel(d.SendToChannel)
	}
	if d.SendDirectMessage != nil {
		return visitor.VisitSendDirectMessage(d.SendDirectMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type Expo struct {
	Token          *Token
	MultipleTokens *MultipleTokens
}

func (e *Expo) UnmarshalJSON(data []byte) error {
	valueToken := new(Token)
	if err := json.Unmarshal(data, &valueToken); err == nil {
		e.Token = valueToken
		return nil
	}
	valueMultipleTokens := new(MultipleTokens)
	if err := json.Unmarshal(data, &valueMultipleTokens); err == nil {
		e.MultipleTokens = valueMultipleTokens
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e Expo) MarshalJSON() ([]byte, error) {
	if e.Token != nil {
		return json.Marshal(e.Token)
	}
	if e.MultipleTokens != nil {
		return json.Marshal(e.MultipleTokens)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ExpoVisitor interface {
	VisitToken(*Token) error
	VisitMultipleTokens(*MultipleTokens) error
}

func (e *Expo) Accept(visitor ExpoVisitor) error {
	if e.Token != nil {
		return visitor.VisitToken(e.Token)
	}
	if e.MultipleTokens != nil {
		return visitor.VisitMultipleTokens(e.MultipleTokens)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type Intercom struct {
	From string             `json:"from" url:"from"`
	To   *IntercomRecipient `json:"to,omitempty" url:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Intercom) UnmarshalJSON(data []byte) error {
	type unmarshaler Intercom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Intercom(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Intercom) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntercomRecipient struct {
	Id string `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (i *IntercomRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler IntercomRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntercomRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntercomRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MsTeams struct {
	SendToMsTeamsUserId         *SendToMsTeamsUserId
	SendToMsTeamsEmail          *SendToMsTeamsEmail
	SendToMsTeamsChannelId      *SendToMsTeamsChannelId
	SendToMsTeamsConversationId *SendToMsTeamsConversationId
	SendToMsTeamsChannelName    *SendToMsTeamsChannelName
}

func (m *MsTeams) UnmarshalJSON(data []byte) error {
	valueSendToMsTeamsUserId := new(SendToMsTeamsUserId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsUserId); err == nil {
		m.SendToMsTeamsUserId = valueSendToMsTeamsUserId
		return nil
	}
	valueSendToMsTeamsEmail := new(SendToMsTeamsEmail)
	if err := json.Unmarshal(data, &valueSendToMsTeamsEmail); err == nil {
		m.SendToMsTeamsEmail = valueSendToMsTeamsEmail
		return nil
	}
	valueSendToMsTeamsChannelId := new(SendToMsTeamsChannelId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsChannelId); err == nil {
		m.SendToMsTeamsChannelId = valueSendToMsTeamsChannelId
		return nil
	}
	valueSendToMsTeamsConversationId := new(SendToMsTeamsConversationId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsConversationId); err == nil {
		m.SendToMsTeamsConversationId = valueSendToMsTeamsConversationId
		return nil
	}
	valueSendToMsTeamsChannelName := new(SendToMsTeamsChannelName)
	if err := json.Unmarshal(data, &valueSendToMsTeamsChannelName); err == nil {
		m.SendToMsTeamsChannelName = valueSendToMsTeamsChannelName
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MsTeams) MarshalJSON() ([]byte, error) {
	if m.SendToMsTeamsUserId != nil {
		return json.Marshal(m.SendToMsTeamsUserId)
	}
	if m.SendToMsTeamsEmail != nil {
		return json.Marshal(m.SendToMsTeamsEmail)
	}
	if m.SendToMsTeamsChannelId != nil {
		return json.Marshal(m.SendToMsTeamsChannelId)
	}
	if m.SendToMsTeamsConversationId != nil {
		return json.Marshal(m.SendToMsTeamsConversationId)
	}
	if m.SendToMsTeamsChannelName != nil {
		return json.Marshal(m.SendToMsTeamsChannelName)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MsTeamsVisitor interface {
	VisitSendToMsTeamsUserId(*SendToMsTeamsUserId) error
	VisitSendToMsTeamsEmail(*SendToMsTeamsEmail) error
	VisitSendToMsTeamsChannelId(*SendToMsTeamsChannelId) error
	VisitSendToMsTeamsConversationId(*SendToMsTeamsConversationId) error
	VisitSendToMsTeamsChannelName(*SendToMsTeamsChannelName) error
}

func (m *MsTeams) Accept(visitor MsTeamsVisitor) error {
	if m.SendToMsTeamsUserId != nil {
		return visitor.VisitSendToMsTeamsUserId(m.SendToMsTeamsUserId)
	}
	if m.SendToMsTeamsEmail != nil {
		return visitor.VisitSendToMsTeamsEmail(m.SendToMsTeamsEmail)
	}
	if m.SendToMsTeamsChannelId != nil {
		return visitor.VisitSendToMsTeamsChannelId(m.SendToMsTeamsChannelId)
	}
	if m.SendToMsTeamsConversationId != nil {
		return visitor.VisitSendToMsTeamsConversationId(m.SendToMsTeamsConversationId)
	}
	if m.SendToMsTeamsChannelName != nil {
		return visitor.VisitSendToMsTeamsChannelName(m.SendToMsTeamsChannelName)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MsTeamsBaseProperties struct {
	TenantId   string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl string `json:"service_url" url:"service_url"`

	_rawJSON json.RawMessage
}

func (m *MsTeamsBaseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler MsTeamsBaseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MsTeamsBaseProperties(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MsTeamsBaseProperties) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleTokens struct {
	Tokens []*Token `json:"tokens,omitempty" url:"tokens,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MultipleTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleTokens(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipleTokens) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Pagerduty struct {
	RoutingKey  *string `json:"routing_key,omitempty" url:"routing_key,omitempty"`
	EventAction *string `json:"event_action,omitempty" url:"event_action,omitempty"`
	Severity    *string `json:"severity,omitempty" url:"severity,omitempty"`
	Source      *string `json:"source,omitempty" url:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Pagerduty) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagerduty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagerduty(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagerduty) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileGetParameters struct {
	RecipientId string `json:"recipientId" url:"recipientId"`

	_rawJSON json.RawMessage
}

func (p *ProfileGetParameters) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileGetParameters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileGetParameters(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileGetParameters) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SendDirectMessage struct {
	UserId string `json:"user_id" url:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendDirectMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SendDirectMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendDirectMessage(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendDirectMessage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToChannel struct {
	ChannelId string `json:"channel_id" url:"channel_id"`

	_rawJSON json.RawMessage
}

func (s *SendToChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToChannel(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToChannel) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsChannelId struct {
	TenantId   string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl string `json:"service_url" url:"service_url"`
	ChannelId  string `json:"channel_id" url:"channel_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsChannelId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsChannelId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsChannelId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsChannelId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsChannelName struct {
	TenantId    string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl  string `json:"service_url" url:"service_url"`
	ChannelName string `json:"channel_name" url:"channel_name"`
	TeamId      string `json:"team_id" url:"team_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsChannelName) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsChannelName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsChannelName(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsChannelName) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsConversationId struct {
	TenantId       string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl     string `json:"service_url" url:"service_url"`
	ConversationId string `json:"conversation_id" url:"conversation_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsConversationId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsConversationId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsConversationId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsConversationId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsEmail struct {
	TenantId   string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl string `json:"service_url" url:"service_url"`
	Email      string `json:"email" url:"email"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsEmail(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsEmail) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsUserId struct {
	TenantId   string `json:"tenant_id" url:"tenant_id"`
	ServiceUrl string `json:"service_url" url:"service_url"`
	UserId     string `json:"user_id" url:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsUserId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsUserId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsUserId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsUserId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackChannel struct {
	AccessToken string `json:"access_token" url:"access_token"`
	Channel     string `json:"channel" url:"channel"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackChannel(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackChannel) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackEmail struct {
	AccessToken string `json:"access_token" url:"access_token"`
	Email       string `json:"email" url:"email"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackEmail(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackEmail) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackUserId struct {
	AccessToken string `json:"access_token" url:"access_token"`
	UserId      string `json:"user_id" url:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackUserId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackUserId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackUserId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackUserId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Slack struct {
	SendToSlackChannel *SendToSlackChannel
	SendToSlackEmail   *SendToSlackEmail
	SendToSlackUserId  *SendToSlackUserId
}

func (s *Slack) UnmarshalJSON(data []byte) error {
	valueSendToSlackChannel := new(SendToSlackChannel)
	if err := json.Unmarshal(data, &valueSendToSlackChannel); err == nil {
		s.SendToSlackChannel = valueSendToSlackChannel
		return nil
	}
	valueSendToSlackEmail := new(SendToSlackEmail)
	if err := json.Unmarshal(data, &valueSendToSlackEmail); err == nil {
		s.SendToSlackEmail = valueSendToSlackEmail
		return nil
	}
	valueSendToSlackUserId := new(SendToSlackUserId)
	if err := json.Unmarshal(data, &valueSendToSlackUserId); err == nil {
		s.SendToSlackUserId = valueSendToSlackUserId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s Slack) MarshalJSON() ([]byte, error) {
	if s.SendToSlackChannel != nil {
		return json.Marshal(s.SendToSlackChannel)
	}
	if s.SendToSlackEmail != nil {
		return json.Marshal(s.SendToSlackEmail)
	}
	if s.SendToSlackUserId != nil {
		return json.Marshal(s.SendToSlackUserId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SlackVisitor interface {
	VisitSendToSlackChannel(*SendToSlackChannel) error
	VisitSendToSlackEmail(*SendToSlackEmail) error
	VisitSendToSlackUserId(*SendToSlackUserId) error
}

func (s *Slack) Accept(visitor SlackVisitor) error {
	if s.SendToSlackChannel != nil {
		return visitor.VisitSendToSlackChannel(s.SendToSlackChannel)
	}
	if s.SendToSlackEmail != nil {
		return visitor.VisitSendToSlackEmail(s.SendToSlackEmail)
	}
	if s.SendToSlackUserId != nil {
		return visitor.VisitSendToSlackUserId(s.SendToSlackUserId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SlackBaseProperties struct {
	AccessToken string `json:"access_token" url:"access_token"`

	_rawJSON json.RawMessage
}

func (s *SlackBaseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SlackBaseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlackBaseProperties(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackBaseProperties) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnoozeRule struct {
	Type  SnoozeRuleType `json:"type,omitempty" url:"type,omitempty"`
	Start string         `json:"start" url:"start"`
	Until string         `json:"until" url:"until"`

	_rawJSON json.RawMessage
}

func (s *SnoozeRule) UnmarshalJSON(data []byte) error {
	type unmarshaler SnoozeRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnoozeRule(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnoozeRule) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnoozeRuleType string

const (
	SnoozeRuleTypeSnooze SnoozeRuleType = "snooze"
)

func NewSnoozeRuleTypeFromString(s string) (SnoozeRuleType, error) {
	switch s {
	case "snooze":
		return SnoozeRuleTypeSnooze, nil
	}
	var t SnoozeRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SnoozeRuleType) Ptr() *SnoozeRuleType {
	return &s
}

type Token struct {
	Token string `json:"token" url:"token"`

	_rawJSON json.RawMessage
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type unmarshaler Token
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Token(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UserProfile struct {
	Address             *Address `json:"address,omitempty" url:"address,omitempty"`
	Birthdate           string   `json:"birthdate" url:"birthdate"`
	Email               string   `json:"email" url:"email"`
	EmailVerified       bool     `json:"email_verified" url:"email_verified"`
	FamilyName          string   `json:"family_name" url:"family_name"`
	Gender              string   `json:"gender" url:"gender"`
	GivenName           string   `json:"given_name" url:"given_name"`
	Locale              string   `json:"locale" url:"locale"`
	MiddleName          string   `json:"middle_name" url:"middle_name"`
	Name                string   `json:"name" url:"name"`
	Nickname            string   `json:"nickname" url:"nickname"`
	PhoneNumber         string   `json:"phone_number" url:"phone_number"`
	PhoneNumberVerified bool     `json:"phone_number_verified" url:"phone_number_verified"`
	Picture             string   `json:"picture" url:"picture"`
	PreferredName       string   `json:"preferred_name" url:"preferred_name"`
	Profile             string   `json:"profile" url:"profile"`
	Sub                 string   `json:"sub" url:"sub"`
	UpdatedAt           string   `json:"updated_at" url:"updated_at"`
	Website             string   `json:"website" url:"website"`
	Zoneinfo            string   `json:"zoneinfo" url:"zoneinfo"`
	// A free form object. Due to a limitation of the API Explorer, you can only enter string key/values below, but this API accepts more complex object structures.
	Custom        interface{}               `json:"custom,omitempty" url:"custom,omitempty"`
	Airship       *AirshipProfile           `json:"airship,omitempty" url:"airship,omitempty"`
	Apn           string                    `json:"apn" url:"apn"`
	TargetArn     string                    `json:"target_arn" url:"target_arn"`
	Discord       *Discord                  `json:"discord,omitempty" url:"discord,omitempty"`
	Expo          *Expo                     `json:"expo,omitempty" url:"expo,omitempty"`
	FacebookPsid  string                    `json:"facebookPSID" url:"facebookPSID"`
	FirebaseToken *UserProfileFirebaseToken `json:"firebaseToken,omitempty" url:"firebaseToken,omitempty"`
	Intercom      *Intercom                 `json:"intercom,omitempty" url:"intercom,omitempty"`
	Slack         *Slack                    `json:"slack,omitempty" url:"slack,omitempty"`
	MsTeams       *MsTeams                  `json:"ms_teams,omitempty" url:"ms_teams,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfile(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfile) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserProfileFirebaseToken struct {
	String     string
	StringList []string
}

func (u *UserProfileFirebaseToken) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		u.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserProfileFirebaseToken) MarshalJSON() ([]byte, error) {
	if u.String != "" {
		return json.Marshal(u.String)
	}
	if u.StringList != nil {
		return json.Marshal(u.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserProfileFirebaseTokenVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (u *UserProfileFirebaseToken) Accept(visitor UserProfileFirebaseTokenVisitor) error {
	if u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.StringList != nil {
		return visitor.VisitStringList(u.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type WebhookAuthMode string

const (
	WebhookAuthModeNone   WebhookAuthMode = "none"
	WebhookAuthModeBasic  WebhookAuthMode = "basic"
	WebhookAuthModeBearer WebhookAuthMode = "bearer"
)

func NewWebhookAuthModeFromString(s string) (WebhookAuthMode, error) {
	switch s {
	case "none":
		return WebhookAuthModeNone, nil
	case "basic":
		return WebhookAuthModeBasic, nil
	case "bearer":
		return WebhookAuthModeBearer, nil
	}
	var t WebhookAuthMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookAuthMode) Ptr() *WebhookAuthMode {
	return &w
}

type WebhookAuthentication struct {
	// The authentication mode to use. Defaults to 'none' if not specified.
	Mode WebhookAuthMode `json:"mode,omitempty" url:"mode,omitempty"`
	// Username for basic authentication.
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	// Password for basic authentication.
	Password *string `json:"password,omitempty" url:"password,omitempty"`
	// Token for bearer authentication.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookAuthentication) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookAuthentication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookAuthentication(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookAuthentication) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookMethod string

const (
	WebhookMethodPost WebhookMethod = "POST"
	WebhookMethodPut  WebhookMethod = "PUT"
)

func NewWebhookMethodFromString(s string) (WebhookMethod, error) {
	switch s {
	case "POST":
		return WebhookMethodPost, nil
	case "PUT":
		return WebhookMethodPut, nil
	}
	var t WebhookMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookMethod) Ptr() *WebhookMethod {
	return &w
}

type WebhookProfile struct {
	// The URL to send the webhook request to.
	Url string `json:"url" url:"url"`
	// The HTTP method to use for the webhook request. Defaults to POST if not specified.
	Method *WebhookMethod `json:"method,omitempty" url:"method,omitempty"`
	// Custom headers to include in the webhook request.
	Headers map[string]string `json:"headers,omitempty" url:"headers,omitempty"`
	// Authentication configuration for the webhook request.
	Authentication *WebhookAuthentication `json:"authentication,omitempty" url:"authentication,omitempty"`
	// Specifies what profile information is included in the request payload. Defaults to 'limited' if not specified.
	Profile *WebhookProfileType `json:"profile,omitempty" url:"profile,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookProfile(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookProfile) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookProfileType string

const (
	WebhookProfileTypeLimited  WebhookProfileType = "limited"
	WebhookProfileTypeExpanded WebhookProfileType = "expanded"
)

func NewWebhookProfileTypeFromString(s string) (WebhookProfileType, error) {
	switch s {
	case "limited":
		return WebhookProfileTypeLimited, nil
	case "expanded":
		return WebhookProfileTypeExpanded, nil
	}
	var t WebhookProfileType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookProfileType) Ptr() *WebhookProfileType {
	return &w
}

type Attachment = map[string]interface{}

type AudienceFilter struct {
	// Send to users only if they are member of the account
	Value    string `json:"value" url:"value"`
	operator string
	path     string

	_rawJSON json.RawMessage
}

func (a *AudienceFilter) Operator() string {
	return a.operator
}

func (a *AudienceFilter) Path() string {
	return a.path
}

func (a *AudienceFilter) UnmarshalJSON(data []byte) error {
	type embed AudienceFilter
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AudienceFilter(unmarshaler.embed)
	a.operator = "MEMBER_OF"
	a.path = "account_id"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceFilter) MarshalJSON() ([]byte, error) {
	type embed AudienceFilter
	var marshaler = struct {
		embed
		Operator string `json:"operator"`
		Path     string `json:"path"`
	}{
		embed:    embed(*a),
		Operator: "MEMBER_OF",
		Path:     "account_id",
	}
	return json.Marshal(marshaler)
}

func (a *AudienceFilter) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AudienceRecipient struct {
	// A unique identifier associated with an Audience. A message will be sent to each user in the audience.
	AudienceId string            `json:"audience_id" url:"audience_id"`
	Data       *MessageData      `json:"data,omitempty" url:"data,omitempty"`
	Filters    []*AudienceFilter `json:"filters,omitempty" url:"filters,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AudienceRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceRecipient(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty" url:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty" url:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty" url:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty" url:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata    *MessageMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Preferences *MessagePreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty" url:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty" url:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Defines the time to wait before delivering the message. You can specify one of the following options. Duration with the number of milliseconds to delay. Until with an ISO 8601 timestamp that specifies when it should be delivered. Until with an OpenStreetMap opening_hours-like format that specifies the [Delivery Window](https://www.courier.com/docs/platform/sending/failover/#delivery-window) (e.g., 'Mo-Fr 08:00-18:00pm')
	Delay *Delay `json:"delay,omitempty" url:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty" url:"expiry,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseMessage(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseMessage) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseMessageSendTo struct {
	// The recipient or a list of recipients of the message
	To *MessageRecipient `json:"to,omitempty" url:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseMessageSendTo) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseMessageSendTo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseMessageSendTo(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseMessageSendTo) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseSocialPresence struct {
	Url string `json:"url" url:"url"`

	_rawJSON json.RawMessage
}

func (b *BaseSocialPresence) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseSocialPresence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseSocialPresence(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseSocialPresence) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsEmail struct {
	TemplateOverride *BrandTemplateOverride `json:"templateOverride,omitempty" url:"templateOverride,omitempty"`
	Head             *EmailHead             `json:"head,omitempty" url:"head,omitempty"`
	Footer           *EmailFooter           `json:"footer,omitempty" url:"footer,omitempty"`
	Header           *EmailHeader           `json:"header,omitempty" url:"header,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsEmail(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsEmail) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsInApp struct {
	BorderRadius       *string           `json:"borderRadius,omitempty" url:"borderRadius,omitempty"`
	DisableMessageIcon *bool             `json:"disableMessageIcon,omitempty" url:"disableMessageIcon,omitempty"`
	FontFamily         *string           `json:"fontFamily,omitempty" url:"fontFamily,omitempty"`
	Placement          *InAppPlacement   `json:"placement,omitempty" url:"placement,omitempty"`
	WidgetBackground   *WidgetBackground `json:"widgetBackground,omitempty" url:"widgetBackground,omitempty"`
	Colors             *BrandColors      `json:"colors,omitempty" url:"colors,omitempty"`
	Icons              *Icons            `json:"icons,omitempty" url:"icons,omitempty"`
	Preferences        *Preferences      `json:"preferences,omitempty" url:"preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsInApp) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsInApp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsInApp(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsInApp) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsSocialPresence struct {
	InheritDefault *bool               `json:"inheritDefault,omitempty" url:"inheritDefault,omitempty"`
	Facebook       *BaseSocialPresence `json:"facebook,omitempty" url:"facebook,omitempty"`
	Instagram      *BaseSocialPresence `json:"instagram,omitempty" url:"instagram,omitempty"`
	Linkedin       *BaseSocialPresence `json:"linkedin,omitempty" url:"linkedin,omitempty"`
	Medium         *BaseSocialPresence `json:"medium,omitempty" url:"medium,omitempty"`
	Twitter        *BaseSocialPresence `json:"twitter,omitempty" url:"twitter,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsSocialPresence) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsSocialPresence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsSocialPresence(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsSocialPresence) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandTemplate struct {
	BackgroundColor       *string `json:"backgroundColor,omitempty" url:"backgroundColor,omitempty"`
	BlocksBackgroundColor *string `json:"blocksBackgroundColor,omitempty" url:"blocksBackgroundColor,omitempty"`
	Enabled               bool    `json:"enabled" url:"enabled"`
	Footer                *string `json:"footer,omitempty" url:"footer,omitempty"`
	Head                  *string `json:"head,omitempty" url:"head,omitempty"`
	Header                *string `json:"header,omitempty" url:"header,omitempty"`
	Width                 *string `json:"width,omitempty" url:"width,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandTemplate) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandTemplate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandTemplate(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandTemplate) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandTemplateOverride struct {
	BackgroundColor       *string        `json:"backgroundColor,omitempty" url:"backgroundColor,omitempty"`
	BlocksBackgroundColor *string        `json:"blocksBackgroundColor,omitempty" url:"blocksBackgroundColor,omitempty"`
	Enabled               bool           `json:"enabled" url:"enabled"`
	Footer                *string        `json:"footer,omitempty" url:"footer,omitempty"`
	Head                  *string        `json:"head,omitempty" url:"head,omitempty"`
	Header                *string        `json:"header,omitempty" url:"header,omitempty"`
	Width                 *string        `json:"width,omitempty" url:"width,omitempty"`
	Mjml                  *BrandTemplate `json:"mjml,omitempty" url:"mjml,omitempty"`
	FooterBackgroundColor *string        `json:"footerBackgroundColor,omitempty" url:"footerBackgroundColor,omitempty"`
	FooterFullWidth       *bool          `json:"footerFullWidth,omitempty" url:"footerFullWidth,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandTemplateOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandTemplateOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandTemplateOverride(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandTemplateOverride) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Channel struct {
	// Id of the brand that should be used for rendering the message.
	// If not specified, the brand configured as default brand will be used.
	BrandId *string `json:"brand_id,omitempty" url:"brand_id,omitempty"`
	// A list of providers enabled for this channel. Courier will select
	// one provider to send through unless routing_method is set to all.
	Providers []string `json:"providers,omitempty" url:"providers,omitempty"`
	// The method for selecting the providers to send the message with.
	// Single will send to one of the available providers for this channel,
	// all will send the message through all channels. Defaults to `single`.
	RoutingMethod *RoutingMethod `json:"routing_method,omitempty" url:"routing_method,omitempty"`
	// A JavaScript conditional expression to determine if the message should
	// be sent through the channel. Has access to the data and profile object.
	// Only applies when a custom routing strategy is defined.
	// For example, `data.name === profile.name`
	If       *string   `json:"if,omitempty" url:"if,omitempty"`
	Timeouts *Timeouts `json:"timeouts,omitempty" url:"timeouts,omitempty"`
	// Channel specific overrides.
	Override map[string]interface{} `json:"override,omitempty" url:"override,omitempty"`
	Metadata *ChannelMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Channel) UnmarshalJSON(data []byte) error {
	type unmarshaler Channel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Channel(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Channel) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChannelMetadata struct {
	Utm *Utm `json:"utm,omitempty" url:"utm,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChannelMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ChannelMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChannelMetadata(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChannelMetadata) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChannelSource string

const (
	ChannelSourceSubscription ChannelSource = "subscription"
	ChannelSourceList         ChannelSource = "list"
	ChannelSourceRecipient    ChannelSource = "recipient"
)

func NewChannelSourceFromString(s string) (ChannelSource, error) {
	switch s {
	case "subscription":
		return ChannelSourceSubscription, nil
	case "list":
		return ChannelSourceList, nil
	case "recipient":
		return ChannelSourceRecipient, nil
	}
	var t ChannelSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChannelSource) Ptr() *ChannelSource {
	return &c
}

type Content struct {
	ElementalContent      *ElementalContent
	ElementalContentSugar *ElementalContentSugar
}

func (c *Content) UnmarshalJSON(data []byte) error {
	valueElementalContent := new(ElementalContent)
	if err := json.Unmarshal(data, &valueElementalContent); err == nil {
		c.ElementalContent = valueElementalContent
		return nil
	}
	valueElementalContentSugar := new(ElementalContentSugar)
	if err := json.Unmarshal(data, &valueElementalContentSugar); err == nil {
		c.ElementalContentSugar = valueElementalContentSugar
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c Content) MarshalJSON() ([]byte, error) {
	if c.ElementalContent != nil {
		return json.Marshal(c.ElementalContent)
	}
	if c.ElementalContentSugar != nil {
		return json.Marshal(c.ElementalContentSugar)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ContentVisitor interface {
	VisitElementalContent(*ElementalContent) error
	VisitElementalContentSugar(*ElementalContentSugar) error
}

func (c *Content) Accept(visitor ContentVisitor) error {
	if c.ElementalContent != nil {
		return visitor.VisitElementalContent(c.ElementalContent)
	}
	if c.ElementalContentSugar != nil {
		return visitor.VisitElementalContentSugar(c.ElementalContentSugar)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// The message property has the following primary top-level properties. They define the destination and content of the message.
// Additional advanced configuration fields [are defined below](https://www.courier.com/docs/reference/send/message/#other-message-properties).
type ContentMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty" url:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty" url:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty" url:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty" url:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata    *MessageMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Preferences *MessagePreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty" url:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty" url:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Defines the time to wait before delivering the message. You can specify one of the following options. Duration with the number of milliseconds to delay. Until with an ISO 8601 timestamp that specifies when it should be delivered. Until with an OpenStreetMap opening_hours-like format that specifies the [Delivery Window](https://www.courier.com/docs/platform/sending/failover/#delivery-window) (e.g., 'Mo-Fr 08:00-18:00pm')
	Delay *Delay `json:"delay,omitempty" url:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty" url:"expiry,omitempty"`
	// The recipient or a list of recipients of the message
	To *MessageRecipient `json:"to,omitempty" url:"to,omitempty"`
	// Describes the content of the message in a way that will work for email, push,
	// chat, or any channel. Either this or template must be specified.
	Content *Content `json:"content,omitempty" url:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ContentMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ContentMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContentMessage(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContentMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Criteria string

const (
	CriteriaNoEscalation Criteria = "no-escalation"
	CriteriaDelivered    Criteria = "delivered"
	CriteriaViewed       Criteria = "viewed"
	CriteriaEngaged      Criteria = "engaged"
)

func NewCriteriaFromString(s string) (Criteria, error) {
	switch s {
	case "no-escalation":
		return CriteriaNoEscalation, nil
	case "delivered":
		return CriteriaDelivered, nil
	case "viewed":
		return CriteriaViewed, nil
	case "engaged":
		return CriteriaEngaged, nil
	}
	var t Criteria
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Criteria) Ptr() *Criteria {
	return &c
}

type Delay struct {
	// The duration of the delay in milliseconds.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// An ISO 8601 timestamp that specifies when it should be delivered or an OpenStreetMap opening_hours-like format that specifies the [Delivery Window](https://www.courier.com/docs/platform/sending/failover/#delivery-window) (e.g., 'Mo-Fr 08:00-18:00pm')
	Until *string `json:"until,omitempty" url:"until,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Delay) UnmarshalJSON(data []byte) error {
	type unmarshaler Delay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Delay(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Delay) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Allows the user to execute an action. Can be a button or a link.
type ElementalActionNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The text content of the action shown to the user.
	Content string `json:"content" url:"content"`
	// The target URL of the action.
	Href string `json:"href" url:"href"`
	// A unique id used to identify the action when it is executed.
	ActionId *string `json:"action_id,omitempty" url:"action_id,omitempty"`
	// The alignment of the action button. Defaults to "center".
	Align *IAlignment `json:"align,omitempty" url:"align,omitempty"`
	// The background color of the action button.
	BackgroundColor *string `json:"background_color,omitempty" url:"background_color,omitempty"`
	// Defaults to `button`.
	Style *IActionButtonStyle `json:"style,omitempty" url:"style,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales Locales `json:"locales,omitempty" url:"locales,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalActionNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalActionNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalActionNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalActionNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalBaseNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalBaseNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalBaseNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalBaseNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalBaseNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The channel element allows a notification to be customized based on which channel it is sent through.
// For example, you may want to display a detailed message when the notification is sent through email,
// and a more concise message in a push notification. Channel elements are only valid as top-level
// elements; you cannot nest channel elements. If there is a channel element specified at the top-level
// of the document, all sibling elements must be channel elements.
// Note: As an alternative, most elements support a `channel` property. Which allows you to selectively
// display an individual element on a per channel basis. See the
// [control flow docs](https://www.courier.com/docs/platform/content/elemental/control-flow/) for more details.
type ElementalChannelNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The channel the contents of this element should be applied to. Can be `email`,
	// `push`, `direct_message`, `sms` or a provider such as slack
	Channel string `json:"channel" url:"channel"`
	// An array of elements to apply to the channel. If `raw` has not been
	// specified, `elements` is `required`.
	Elements []*ElementalNode `json:"elements,omitempty" url:"elements,omitempty"`
	// Raw data to apply to the channel. If `elements` has not been
	// specified, `raw` is `required`.
	Raw map[string]interface{} `json:"raw,omitempty" url:"raw,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalChannelNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalChannelNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalChannelNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalChannelNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalContent struct {
	// For example, "2022-01-01"
	Version  string           `json:"version" url:"version"`
	Brand    interface{}      `json:"brand,omitempty" url:"brand,omitempty"`
	Elements []*ElementalNode `json:"elements,omitempty" url:"elements,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalContent(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalContent) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Syntatic Sugar to provide a fast shorthand for Courier Elemental Blocks.
type ElementalContentSugar struct {
	// The title to be displayed by supported channels i.e. push, email (as subject)
	Title string `json:"title" url:"title"`
	// The text content displayed in the notification.
	Body string `json:"body" url:"body"`

	_rawJSON json.RawMessage
}

func (e *ElementalContentSugar) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalContentSugar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalContentSugar(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalContentSugar) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Renders a dividing line between elements.
type ElementalDividerNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The CSS color to render the line with. For example, `#fff`
	Color *string `json:"color,omitempty" url:"color,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalDividerNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalDividerNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalDividerNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalDividerNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Allows you to group elements together. This can be useful when used in combination with "if" or "loop". See [control flow docs](https://www.courier.com/docs/platform/content/elemental/control-flow/) for more details.
type ElementalGroupNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// Sub elements to render.
	Elements []*ElementalNode `json:"elements,omitempty" url:"elements,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalGroupNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalGroupNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalGroupNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalGroupNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Used to embed an image into the notification.
type ElementalImageNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The source of the image.
	Src string `json:"src" url:"src"`
	// A URL to link to when the image is clicked.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// The alignment of the image.
	Align *IAlignment `json:"align,omitempty" url:"align,omitempty"`
	// Alternate text for the image.
	AltText *string `json:"altText,omitempty" url:"altText,omitempty"`
	// CSS width properties to apply to the image. For example, 50px
	Width *string `json:"width,omitempty" url:"width,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalImageNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalImageNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalImageNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalImageNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The meta element contains information describing the notification that may
// be used by a particular channel or provider. One important field is the title
// field which will be used as the title for channels that support it.
type ElementalMetaNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The title to be displayed by supported channels. For example, the email subject.
	Title *string `json:"title,omitempty" url:"title,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalMetaNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalMetaNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalMetaNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalMetaNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalNode struct {
	Type    string
	Text    *ElementalTextNode
	Meta    *ElementalMetaNode
	Channel *ElementalChannelNode
	Image   *ElementalImageNode
	Action  *ElementalActionNode
	Divider *ElementalDividerNode
	Group   *ElementalGroupNode
	Quote   *ElementalQuoteNode
}

func (e *ElementalNode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "text":
		value := new(ElementalTextNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Text = value
	case "meta":
		value := new(ElementalMetaNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Meta = value
	case "channel":
		value := new(ElementalChannelNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Channel = value
	case "image":
		value := new(ElementalImageNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Image = value
	case "action":
		value := new(ElementalActionNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Action = value
	case "divider":
		value := new(ElementalDividerNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Divider = value
	case "group":
		value := new(ElementalGroupNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Group = value
	case "quote":
		value := new(ElementalQuoteNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Quote = value
	}
	return nil
}

func (e ElementalNode) MarshalJSON() ([]byte, error) {
	if e.Text != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalTextNode
		}{
			Type:              "text",
			ElementalTextNode: e.Text,
		}
		return json.Marshal(marshaler)
	}
	if e.Meta != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalMetaNode
		}{
			Type:              "meta",
			ElementalMetaNode: e.Meta,
		}
		return json.Marshal(marshaler)
	}
	if e.Channel != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalChannelNode
		}{
			Type:                 "channel",
			ElementalChannelNode: e.Channel,
		}
		return json.Marshal(marshaler)
	}
	if e.Image != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalImageNode
		}{
			Type:               "image",
			ElementalImageNode: e.Image,
		}
		return json.Marshal(marshaler)
	}
	if e.Action != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalActionNode
		}{
			Type:                "action",
			ElementalActionNode: e.Action,
		}
		return json.Marshal(marshaler)
	}
	if e.Divider != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalDividerNode
		}{
			Type:                 "divider",
			ElementalDividerNode: e.Divider,
		}
		return json.Marshal(marshaler)
	}
	if e.Group != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalGroupNode
		}{
			Type:               "group",
			ElementalGroupNode: e.Group,
		}
		return json.Marshal(marshaler)
	}
	if e.Quote != nil {
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalQuoteNode
		}{
			Type:               "quote",
			ElementalQuoteNode: e.Quote,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElementalNodeVisitor interface {
	VisitText(*ElementalTextNode) error
	VisitMeta(*ElementalMetaNode) error
	VisitChannel(*ElementalChannelNode) error
	VisitImage(*ElementalImageNode) error
	VisitAction(*ElementalActionNode) error
	VisitDivider(*ElementalDividerNode) error
	VisitGroup(*ElementalGroupNode) error
	VisitQuote(*ElementalQuoteNode) error
}

func (e *ElementalNode) Accept(visitor ElementalNodeVisitor) error {
	if e.Text != nil {
		return visitor.VisitText(e.Text)
	}
	if e.Meta != nil {
		return visitor.VisitMeta(e.Meta)
	}
	if e.Channel != nil {
		return visitor.VisitChannel(e.Channel)
	}
	if e.Image != nil {
		return visitor.VisitImage(e.Image)
	}
	if e.Action != nil {
		return visitor.VisitAction(e.Action)
	}
	if e.Divider != nil {
		return visitor.VisitDivider(e.Divider)
	}
	if e.Group != nil {
		return visitor.VisitGroup(e.Group)
	}
	if e.Quote != nil {
		return visitor.VisitQuote(e.Quote)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

// Renders a quote block.
type ElementalQuoteNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The text value of the quote.
	Content string `json:"content" url:"content"`
	// Alignment of the quote.
	Align *IAlignment `json:"align,omitempty" url:"align,omitempty"`
	// CSS border color property. For example, `#fff`
	BorderColor *string   `json:"borderColor,omitempty" url:"borderColor,omitempty"`
	TextStyle   TextStyle `json:"text_style,omitempty" url:"text_style,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales Locales `json:"locales,omitempty" url:"locales,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalQuoteNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalQuoteNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalQuoteNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalQuoteNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents a body of text to be rendered inside of the notification.
type ElementalTextNode struct {
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty" url:"ref,omitempty"`
	If       *string  `json:"if,omitempty" url:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty" url:"loop,omitempty"`
	// The text content displayed in the notification. Either this
	// field must be specified, or the elements field
	Content string `json:"content" url:"content"`
	// Text alignment.
	Align TextAlign `json:"align,omitempty" url:"align,omitempty"`
	// Allows the text to be rendered as a heading level.
	TextStyle *TextStyle `json:"text_style,omitempty" url:"text_style,omitempty"`
	// Specifies the color of text. Can be any valid css color value
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Apply bold to the text
	Bold *string `json:"bold,omitempty" url:"bold,omitempty"`
	// Apply italics to the text
	Italic *string `json:"italic,omitempty" url:"italic,omitempty"`
	// Apply a strike through the text
	Strikethrough *string `json:"strikethrough,omitempty" url:"strikethrough,omitempty"`
	// Apply an underline to the text
	Underline *string `json:"underline,omitempty" url:"underline,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales *Locales `json:"locales,omitempty" url:"locales,omitempty"`
	Format  *string  `json:"format,omitempty" url:"format,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalTextNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalTextNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalTextNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalTextNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailFooter struct {
	Content        interface{} `json:"content,omitempty" url:"content,omitempty"`
	InheritDefault *bool       `json:"inheritDefault,omitempty" url:"inheritDefault,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailFooter) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailFooter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailFooter(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailFooter) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailHead struct {
	InheritDefault bool    `json:"inheritDefault" url:"inheritDefault"`
	Content        *string `json:"content,omitempty" url:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailHead) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailHead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailHead(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailHead) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailHeader struct {
	InheritDefault *bool   `json:"inheritDefault,omitempty" url:"inheritDefault,omitempty"`
	BarColor       *string `json:"barColor,omitempty" url:"barColor,omitempty"`
	Logo           *Logo   `json:"logo,omitempty" url:"logo,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailHeader(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailHeader) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExpiresInType struct {
	String  string
	Integer int
}

func (e *ExpiresInType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpiresInType) MarshalJSON() ([]byte, error) {
	if e.String != "" {
		return json.Marshal(e.String)
	}
	if e.Integer != 0 {
		return json.Marshal(e.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ExpiresInTypeVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (e *ExpiresInType) Accept(visitor ExpiresInTypeVisitor) error {
	if e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.Integer != 0 {
		return visitor.VisitInteger(e.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type Expiry struct {
	// An epoch timestamp or ISO8601 timestamp with timezone `(YYYY-MM-DDThh:mm:ss.sTZD)` that describes the time in which a message expires.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// A duration in the form of milliseconds or an ISO8601 Duration format (i.e. P1DT4H).
	ExpiresIn *ExpiresInType `json:"expires_in,omitempty" url:"expires_in,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Expiry) UnmarshalJSON(data []byte) error {
	type unmarshaler Expiry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Expiry(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Expiry) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type IActionButtonStyle string

const (
	IActionButtonStyleButton IActionButtonStyle = "button"
	IActionButtonStyleLink   IActionButtonStyle = "link"
)

func NewIActionButtonStyleFromString(s string) (IActionButtonStyle, error) {
	switch s {
	case "button":
		return IActionButtonStyleButton, nil
	case "link":
		return IActionButtonStyleLink, nil
	}
	var t IActionButtonStyle
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IActionButtonStyle) Ptr() *IActionButtonStyle {
	return &i
}

type IAlignment string

const (
	IAlignmentCenter IAlignment = "center"
	IAlignmentLeft   IAlignment = "left"
	IAlignmentRight  IAlignment = "right"
	IAlignmentFull   IAlignment = "full"
)

func NewIAlignmentFromString(s string) (IAlignment, error) {
	switch s {
	case "center":
		return IAlignmentCenter, nil
	case "left":
		return IAlignmentLeft, nil
	case "right":
		return IAlignmentRight, nil
	case "full":
		return IAlignmentFull, nil
	}
	var t IAlignment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IAlignment) Ptr() *IAlignment {
	return &i
}

type IPreferences = map[string]*Preference

type IProfilePreferences struct {
	Categories    *IPreferences `json:"categories,omitempty" url:"categories,omitempty"`
	Notifications IPreferences  `json:"notifications,omitempty" url:"notifications,omitempty"`
	TemplateId    *string       `json:"templateId,omitempty" url:"templateId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IProfilePreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler IProfilePreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IProfilePreferences(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IProfilePreferences) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Icons struct {
	Bell    *string `json:"bell,omitempty" url:"bell,omitempty"`
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Icons) UnmarshalJSON(data []byte) error {
	type unmarshaler Icons
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Icons(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Icons) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InAppPlacement string

const (
	InAppPlacementTop    InAppPlacement = "top"
	InAppPlacementBottom InAppPlacement = "bottom"
	InAppPlacementLeft   InAppPlacement = "left"
	InAppPlacementRight  InAppPlacement = "right"
)

func NewInAppPlacementFromString(s string) (InAppPlacement, error) {
	switch s {
	case "top":
		return InAppPlacementTop, nil
	case "bottom":
		return InAppPlacementBottom, nil
	case "left":
		return InAppPlacementLeft, nil
	case "right":
		return InAppPlacementRight, nil
	}
	var t InAppPlacement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InAppPlacement) Ptr() *InAppPlacement {
	return &i
}

type InvalidListPatternRecipient struct {
	UserId string `json:"user_id" url:"user_id"`
	ListId string `json:"list_id" url:"list_id"`

	_rawJSON json.RawMessage
}

func (i *InvalidListPatternRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidListPatternRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidListPatternRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidListPatternRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvalidListRecipient struct {
	UserId      string `json:"user_id" url:"user_id"`
	ListPattern string `json:"list_pattern" url:"list_pattern"`

	_rawJSON json.RawMessage
}

func (i *InvalidListRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidListRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidListRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidListRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvalidUserRecipient struct {
	ListId      string `json:"list_id" url:"list_id"`
	ListPattern string `json:"list_pattern" url:"list_pattern"`

	_rawJSON json.RawMessage
}

func (i *InvalidUserRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidUserRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidUserRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidUserRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type ListFilter struct {
	// Send to users only if they are member of the account
	Value    string `json:"value" url:"value"`
	operator string
	path     string

	_rawJSON json.RawMessage
}

func (l *ListFilter) Operator() string {
	return l.operator
}

func (l *ListFilter) Path() string {
	return l.path
}

func (l *ListFilter) UnmarshalJSON(data []byte) error {
	type embed ListFilter
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = ListFilter(unmarshaler.embed)
	l.operator = "MEMBER_OF"
	l.path = "account_id"
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListFilter) MarshalJSON() ([]byte, error) {
	type embed ListFilter
	var marshaler = struct {
		embed
		Operator string `json:"operator"`
		Path     string `json:"path"`
	}{
		embed:    embed(*l),
		Operator: "MEMBER_OF",
		Path:     "account_id",
	}
	return json.Marshal(marshaler)
}

func (l *ListFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPatternRecipient struct {
	ListPattern *string      `json:"list_pattern,omitempty" url:"list_pattern,omitempty"`
	Data        *MessageData `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListPatternRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPatternRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPatternRecipient(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPatternRecipient) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPatternRecipientType struct {
	_rawJSON json.RawMessage
}

func (l *ListPatternRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPatternRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPatternRecipientType(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPatternRecipientType) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListRecipient struct {
	ListId  *string       `json:"list_id,omitempty" url:"list_id,omitempty"`
	Data    *MessageData  `json:"data,omitempty" url:"data,omitempty"`
	Filters []*ListFilter `json:"filters,omitempty" url:"filters,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRecipient(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRecipient) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListRecipientType struct {
	_rawJSON json.RawMessage
}

func (l *ListRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRecipientType(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRecipientType) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Locale struct {
	Content string `json:"content" url:"content"`

	_rawJSON json.RawMessage
}

func (l *Locale) UnmarshalJSON(data []byte) error {
	type unmarshaler Locale
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Locale(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Locale) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Locales = map[string]*Locale

type Logo struct {
	Href  *string `json:"href,omitempty" url:"href,omitempty"`
	Image *string `json:"image,omitempty" url:"image,omitempty"`

	_rawJSON json.RawMessage
}

func (l *Logo) UnmarshalJSON(data []byte) error {
	type unmarshaler Logo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Logo(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Logo) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Message struct {
	// Describes the content of the message in a way that will work for email, push, chat, or any channel.
	ContentMessage *ContentMessage
	// A template for a type of message that can be sent more than once. For example, you might create an "Appointment Reminder" Notification or “Reset Password” Notifications.
	TemplateMessage *TemplateMessage
}

func (m *Message) UnmarshalJSON(data []byte) error {
	valueContentMessage := new(ContentMessage)
	if err := json.Unmarshal(data, &valueContentMessage); err == nil {
		m.ContentMessage = valueContentMessage
		return nil
	}
	valueTemplateMessage := new(TemplateMessage)
	if err := json.Unmarshal(data, &valueTemplateMessage); err == nil {
		m.TemplateMessage = valueTemplateMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m Message) MarshalJSON() ([]byte, error) {
	if m.ContentMessage != nil {
		return json.Marshal(m.ContentMessage)
	}
	if m.TemplateMessage != nil {
		return json.Marshal(m.TemplateMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessageVisitor interface {
	VisitContentMessage(*ContentMessage) error
	VisitTemplateMessage(*TemplateMessage) error
}

func (m *Message) Accept(visitor MessageVisitor) error {
	if m.ContentMessage != nil {
		return visitor.VisitContentMessage(m.ContentMessage)
	}
	if m.TemplateMessage != nil {
		return visitor.VisitTemplateMessage(m.TemplateMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessageChannels = map[string]*Channel

type MessageContext struct {
	// An id of a tenant, see [tenants api docs](https://www.courier.com/docs/reference/tenants/).
	// Will load brand, default preferences and any other base context data associated with this tenant.
	TenantId *string `json:"tenant_id,omitempty" url:"tenant_id,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageContext) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageContext(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageContext) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageData = map[string]interface{}

type MessageMetadata struct {
	// An arbitrary string to tracks the event that generated this request (e.g. 'signup').
	Event *string `json:"event,omitempty" url:"event,omitempty"`
	// An array of up to 9 tags you wish to associate with this request (and corresponding messages) for later analysis. Individual tags cannot be more than 30 characters in length.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// Identify the campaign that refers traffic to a specific website, and attributes the browser's website session.
	Utm *Utm `json:"utm,omitempty" url:"utm,omitempty"`
	// A unique ID used to correlate this request to processing on your servers. Note: Courier does not verify the uniqueness of this ID.
	TraceId *string `json:"trace_id,omitempty" url:"trace_id,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageMetadata(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageMetadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessagePreferences struct {
	// The ID of the subscription topic you want to apply to the message. If this is a templated message, it will override the subscription topic if already associated
	SubscriptionTopicId string `json:"subscription_topic_id" url:"subscription_topic_id"`

	_rawJSON json.RawMessage
}

func (m *MessagePreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler MessagePreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessagePreferences(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessagePreferences) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageProviders = map[string]*MessageProvidersType

type MessageProvidersType struct {
	// Provider specific overrides.
	Override map[string]interface{} `json:"override,omitempty" url:"override,omitempty"`
	// A JavaScript conditional expression to determine if the message should
	// be sent through the provider. Has access to the data and profile object.
	// Only applies when a custom routing strategy is defined.
	// For example, `data.name === profile.name`
	If       *string   `json:"if,omitempty" url:"if,omitempty"`
	Timeouts *int      `json:"timeouts,omitempty" url:"timeouts,omitempty"`
	Metadata *Metadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageProvidersType) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageProvidersType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageProvidersType(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageProvidersType) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageRecipient struct {
	Recipient     *Recipient
	RecipientList []*Recipient
}

func (m *MessageRecipient) UnmarshalJSON(data []byte) error {
	valueRecipient := new(Recipient)
	if err := json.Unmarshal(data, &valueRecipient); err == nil {
		m.Recipient = valueRecipient
		return nil
	}
	var valueRecipientList []*Recipient
	if err := json.Unmarshal(data, &valueRecipientList); err == nil {
		m.RecipientList = valueRecipientList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MessageRecipient) MarshalJSON() ([]byte, error) {
	if m.Recipient != nil {
		return json.Marshal(m.Recipient)
	}
	if m.RecipientList != nil {
		return json.Marshal(m.RecipientList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessageRecipientVisitor interface {
	VisitRecipient(*Recipient) error
	VisitRecipientList([]*Recipient) error
}

func (m *MessageRecipient) Accept(visitor MessageRecipientVisitor) error {
	if m.Recipient != nil {
		return visitor.VisitRecipient(m.Recipient)
	}
	if m.RecipientList != nil {
		return visitor.VisitRecipientList(m.RecipientList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type Metadata struct {
	Utm *Utm `json:"utm,omitempty" url:"utm,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MsTeamsRecipient struct {
	MsTeams *MsTeams `json:"ms_teams,omitempty" url:"ms_teams,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MsTeamsRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler MsTeamsRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MsTeamsRecipient(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MsTeamsRecipient) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PagerdutyRecipient struct {
	Pagerduty *Pagerduty `json:"pagerduty,omitempty" url:"pagerduty,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PagerdutyRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler PagerdutyRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PagerdutyRecipient(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PagerdutyRecipient) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Preference struct {
	Status             PreferenceStatus     `json:"status,omitempty" url:"status,omitempty"`
	Rules              []*Rule              `json:"rules,omitempty" url:"rules,omitempty"`
	ChannelPreferences []*ChannelPreference `json:"channel_preferences,omitempty" url:"channel_preferences,omitempty"`
	Source             *ChannelSource       `json:"source,omitempty" url:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Preference) UnmarshalJSON(data []byte) error {
	type unmarshaler Preference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Preference(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Preference) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Preferences struct {
	TemplateIds []string `json:"templateIds,omitempty" url:"templateIds,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Preferences) UnmarshalJSON(data []byte) error {
	type unmarshaler Preferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Preferences(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Preferences) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Recipient struct {
	AudienceRecipient    *AudienceRecipient
	ListRecipient        *ListRecipient
	ListPatternRecipient *ListPatternRecipient
	UserRecipient        *UserRecipient
	SlackRecipient       *SlackRecipient
	MsTeamsRecipient     *MsTeamsRecipient
	RecipientData        RecipientData
	PagerdutyRecipient   *PagerdutyRecipient
	WebhookRecipient     *WebhookRecipient
}

func (r *Recipient) UnmarshalJSON(data []byte) error {
	valueAudienceRecipient := new(AudienceRecipient)
	if err := json.Unmarshal(data, &valueAudienceRecipient); err == nil {
		r.AudienceRecipient = valueAudienceRecipient
		return nil
	}
	valueListRecipient := new(ListRecipient)
	if err := json.Unmarshal(data, &valueListRecipient); err == nil {
		r.ListRecipient = valueListRecipient
		return nil
	}
	valueListPatternRecipient := new(ListPatternRecipient)
	if err := json.Unmarshal(data, &valueListPatternRecipient); err == nil {
		r.ListPatternRecipient = valueListPatternRecipient
		return nil
	}
	valueUserRecipient := new(UserRecipient)
	if err := json.Unmarshal(data, &valueUserRecipient); err == nil {
		r.UserRecipient = valueUserRecipient
		return nil
	}
	valueSlackRecipient := new(SlackRecipient)
	if err := json.Unmarshal(data, &valueSlackRecipient); err == nil {
		r.SlackRecipient = valueSlackRecipient
		return nil
	}
	valueMsTeamsRecipient := new(MsTeamsRecipient)
	if err := json.Unmarshal(data, &valueMsTeamsRecipient); err == nil {
		r.MsTeamsRecipient = valueMsTeamsRecipient
		return nil
	}
	var valueRecipientData RecipientData
	if err := json.Unmarshal(data, &valueRecipientData); err == nil {
		r.RecipientData = valueRecipientData
		return nil
	}
	valuePagerdutyRecipient := new(PagerdutyRecipient)
	if err := json.Unmarshal(data, &valuePagerdutyRecipient); err == nil {
		r.PagerdutyRecipient = valuePagerdutyRecipient
		return nil
	}
	valueWebhookRecipient := new(WebhookRecipient)
	if err := json.Unmarshal(data, &valueWebhookRecipient); err == nil {
		r.WebhookRecipient = valueWebhookRecipient
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Recipient) MarshalJSON() ([]byte, error) {
	if r.AudienceRecipient != nil {
		return json.Marshal(r.AudienceRecipient)
	}
	if r.ListRecipient != nil {
		return json.Marshal(r.ListRecipient)
	}
	if r.ListPatternRecipient != nil {
		return json.Marshal(r.ListPatternRecipient)
	}
	if r.UserRecipient != nil {
		return json.Marshal(r.UserRecipient)
	}
	if r.SlackRecipient != nil {
		return json.Marshal(r.SlackRecipient)
	}
	if r.MsTeamsRecipient != nil {
		return json.Marshal(r.MsTeamsRecipient)
	}
	if r.RecipientData != nil {
		return json.Marshal(r.RecipientData)
	}
	if r.PagerdutyRecipient != nil {
		return json.Marshal(r.PagerdutyRecipient)
	}
	if r.WebhookRecipient != nil {
		return json.Marshal(r.WebhookRecipient)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RecipientVisitor interface {
	VisitAudienceRecipient(*AudienceRecipient) error
	VisitListRecipient(*ListRecipient) error
	VisitListPatternRecipient(*ListPatternRecipient) error
	VisitUserRecipient(*UserRecipient) error
	VisitSlackRecipient(*SlackRecipient) error
	VisitMsTeamsRecipient(*MsTeamsRecipient) error
	VisitRecipientData(RecipientData) error
	VisitPagerdutyRecipient(*PagerdutyRecipient) error
	VisitWebhookRecipient(*WebhookRecipient) error
}

func (r *Recipient) Accept(visitor RecipientVisitor) error {
	if r.AudienceRecipient != nil {
		return visitor.VisitAudienceRecipient(r.AudienceRecipient)
	}
	if r.ListRecipient != nil {
		return visitor.VisitListRecipient(r.ListRecipient)
	}
	if r.ListPatternRecipient != nil {
		return visitor.VisitListPatternRecipient(r.ListPatternRecipient)
	}
	if r.UserRecipient != nil {
		return visitor.VisitUserRecipient(r.UserRecipient)
	}
	if r.SlackRecipient != nil {
		return visitor.VisitSlackRecipient(r.SlackRecipient)
	}
	if r.MsTeamsRecipient != nil {
		return visitor.VisitMsTeamsRecipient(r.MsTeamsRecipient)
	}
	if r.RecipientData != nil {
		return visitor.VisitRecipientData(r.RecipientData)
	}
	if r.PagerdutyRecipient != nil {
		return visitor.VisitPagerdutyRecipient(r.PagerdutyRecipient)
	}
	if r.WebhookRecipient != nil {
		return visitor.VisitWebhookRecipient(r.WebhookRecipient)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RecipientData = map[string]interface{}

// Allows you to customize which channel(s) Courier will potentially deliver the message.
// If no routing key is specified, Courier will use the default routing configuration or
// routing defined by the template.
type Routing struct {
	Method RoutingMethod `json:"method,omitempty" url:"method,omitempty"`
	// A list of channels or providers to send the message through. Can also recursively define
	// sub-routing methods, which can be useful for defining advanced push notification
	// delivery strategies.
	Channels []*MessageRoutingChannel `json:"channels,omitempty" url:"channels,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Routing) UnmarshalJSON(data []byte) error {
	type unmarshaler Routing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Routing(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Routing) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoutingMethod string

const (
	RoutingMethodAll    RoutingMethod = "all"
	RoutingMethodSingle RoutingMethod = "single"
)

func NewRoutingMethodFromString(s string) (RoutingMethod, error) {
	switch s {
	case "all":
		return RoutingMethodAll, nil
	case "single":
		return RoutingMethodSingle, nil
	}
	var t RoutingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoutingMethod) Ptr() *RoutingMethod {
	return &r
}

type RuleType string

const (
	RuleTypeSnooze             RuleType = "snooze"
	RuleTypeChannelPreferences RuleType = "channel_preferences"
	RuleTypeStatus             RuleType = "status"
)

func NewRuleTypeFromString(s string) (RuleType, error) {
	switch s {
	case "snooze":
		return RuleTypeSnooze, nil
	case "channel_preferences":
		return RuleTypeChannelPreferences, nil
	case "status":
		return RuleTypeStatus, nil
	}
	var t RuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleType) Ptr() *RuleType {
	return &r
}

type SlackRecipient struct {
	Slack *Slack `json:"slack,omitempty" url:"slack,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SlackRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler SlackRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlackRecipient(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackRecipient) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TemplateMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty" url:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty" url:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty" url:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty" url:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata    *MessageMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Preferences *MessagePreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty" url:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty" url:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Defines the time to wait before delivering the message. You can specify one of the following options. Duration with the number of milliseconds to delay. Until with an ISO 8601 timestamp that specifies when it should be delivered. Until with an OpenStreetMap opening_hours-like format that specifies the [Delivery Window](https://www.courier.com/docs/platform/sending/failover/#delivery-window) (e.g., 'Mo-Fr 08:00-18:00pm')
	Delay *Delay `json:"delay,omitempty" url:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty" url:"expiry,omitempty"`
	// The recipient or a list of recipients of the message
	To *MessageRecipient `json:"to,omitempty" url:"to,omitempty"`
	// The id of the notification template to be rendered and sent to the recipient(s).
	// This field or the content field must be supplied.
	Template string `json:"template" url:"template"`

	_rawJSON json.RawMessage
}

func (t *TemplateMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler TemplateMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TemplateMessage(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TemplateMessage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextAlign string

const (
	TextAlignLeft   TextAlign = "left"
	TextAlignCenter TextAlign = "center"
	TextAlignRight  TextAlign = "right"
)

func NewTextAlignFromString(s string) (TextAlign, error) {
	switch s {
	case "left":
		return TextAlignLeft, nil
	case "center":
		return TextAlignCenter, nil
	case "right":
		return TextAlignRight, nil
	}
	var t TextAlign
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextAlign) Ptr() *TextAlign {
	return &t
}

type TextStyle string

const (
	TextStyleText    TextStyle = "text"
	TextStyleH1      TextStyle = "h1"
	TextStyleH2      TextStyle = "h2"
	TextStyleSubtext TextStyle = "subtext"
)

func NewTextStyleFromString(s string) (TextStyle, error) {
	switch s {
	case "text":
		return TextStyleText, nil
	case "h1":
		return TextStyleH1, nil
	case "h2":
		return TextStyleH2, nil
	case "subtext":
		return TextStyleSubtext, nil
	}
	var t TextStyle
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextStyle) Ptr() *TextStyle {
	return &t
}

type Timeout struct {
	Provider   map[string]int `json:"provider,omitempty" url:"provider,omitempty"`
	Channel    map[string]int `json:"channel,omitempty" url:"channel,omitempty"`
	Message    *int           `json:"message,omitempty" url:"message,omitempty"`
	Escalation *int           `json:"escalation,omitempty" url:"escalation,omitempty"`
	Criteria   *Criteria      `json:"criteria,omitempty" url:"criteria,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Timeout) UnmarshalJSON(data []byte) error {
	type unmarshaler Timeout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Timeout(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Timeout) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Timeouts struct {
	Provider *int `json:"provider,omitempty" url:"provider,omitempty"`
	Channel  *int `json:"channel,omitempty" url:"channel,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Timeouts) UnmarshalJSON(data []byte) error {
	type unmarshaler Timeouts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Timeouts(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Timeouts) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TrackingOverride struct {
	Open bool `json:"open" url:"open"`

	_rawJSON json.RawMessage
}

func (t *TrackingOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler TrackingOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrackingOverride(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrackingOverride) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Utm struct {
	Source   *string `json:"source,omitempty" url:"source,omitempty"`
	Medium   *string `json:"medium,omitempty" url:"medium,omitempty"`
	Campaign *string `json:"campaign,omitempty" url:"campaign,omitempty"`
	Term     *string `json:"term,omitempty" url:"term,omitempty"`
	Content  *string `json:"content,omitempty" url:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (u *Utm) UnmarshalJSON(data []byte) error {
	type unmarshaler Utm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Utm(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *Utm) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRecipient struct {
	// Use `tenant_id` instad.
	AccountId *string `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Context information such as tenant_id to send the notification with.
	Context *MessageContext `json:"context,omitempty" url:"context,omitempty"`
	Data    *MessageData    `json:"data,omitempty" url:"data,omitempty"`
	Email   *string         `json:"email,omitempty" url:"email,omitempty"`
	// The user's preferred ISO 639-1 language code.
	Locale      *string              `json:"locale,omitempty" url:"locale,omitempty"`
	UserId      *string              `json:"user_id,omitempty" url:"user_id,omitempty"`
	PhoneNumber *string              `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Preferences *IProfilePreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// An id of a tenant, [see tenants api docs](https://www.courier.com/docs/reference/tenants).
	// Will load brand, default preferences and any other base context data associated with this tenant.
	TenantId *string `json:"tenant_id,omitempty" url:"tenant_id,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRecipient(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRecipient) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRecipientType struct {
	_rawJSON json.RawMessage
}

func (u *UserRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRecipientType(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRecipientType) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type WebhookRecipient struct {
	Webhook *WebhookProfile `json:"webhook,omitempty" url:"webhook,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookRecipient(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookRecipient) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WidgetBackground struct {
	TopColor    *string `json:"topColor,omitempty" url:"topColor,omitempty"`
	BottomColor *string `json:"bottomColor,omitempty" url:"bottomColor,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WidgetBackground) UnmarshalJSON(data []byte) error {
	type unmarshaler WidgetBackground
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WidgetBackground(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WidgetBackground) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Unused type for tenants
type TemplateProperty = interface{}
