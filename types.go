// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/trycourier/courier-go/v3/core"
)

type SendMessageRequest struct {
	// Defines the message to be delivered
	Message *Message `json:"message,omitempty"`
}

type SendMessageResponse struct {
	// A successful call to `POST /send` returns a `202` status code along with a `requestId` in the response body.
	//
	// For send requests that have a single recipient, the `requestId` is assigned to the derived message as its message_id. Therefore the `requestId` can be supplied to the Message's API for single recipient messages.
	//
	// For send requests that have multiple recipients (accounts, audiences, lists, etc.), Courier assigns a unique id to each derived message as its `message_id`. Therefore the `requestId` cannot be supplied to the Message's API for single-recipient messages.
	RequestId string `json:"requestId"`

	_rawJSON json.RawMessage
}

func (s *SendMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SendMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendMessageResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendMessageResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type AudienceMember struct {
	AddedAt         string `json:"added_at"`
	AudienceId      string `json:"audience_id"`
	AudienceVersion int    `json:"audience_version"`
	MemberId        string `json:"member_id"`
	Reason          string `json:"reason"`

	_rawJSON json.RawMessage
}

func (a *AudienceMember) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMember(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMember) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AudienceMemberGetResponse struct {
	AudienceMember *AudienceMember `json:"audienceMember,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AudienceMemberGetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMemberGetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMemberGetResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMemberGetResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator `json:"operator,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseFilterConfig(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseFilterConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ComparisonOperator string

const (
	ComparisonOperatorEndsWith   ComparisonOperator = "ENDS_WITH"
	ComparisonOperatorEq         ComparisonOperator = "EQ"
	ComparisonOperatorExists     ComparisonOperator = "EXISTS"
	ComparisonOperatorGt         ComparisonOperator = "GT"
	ComparisonOperatorGte        ComparisonOperator = "GTE"
	ComparisonOperatorIncludes   ComparisonOperator = "INCLUDES"
	ComparisonOperatorIsAfter    ComparisonOperator = "IS_AFTER"
	ComparisonOperatorIsBefore   ComparisonOperator = "IS_BEFORE"
	ComparisonOperatorLt         ComparisonOperator = "LT"
	ComparisonOperatorLte        ComparisonOperator = "LTE"
	ComparisonOperatorNeq        ComparisonOperator = "NEQ"
	ComparisonOperatorOmit       ComparisonOperator = "OMIT"
	ComparisonOperatorStartsWith ComparisonOperator = "STARTS_WITH"
)

func NewComparisonOperatorFromString(s string) (ComparisonOperator, error) {
	switch s {
	case "ENDS_WITH":
		return ComparisonOperatorEndsWith, nil
	case "EQ":
		return ComparisonOperatorEq, nil
	case "EXISTS":
		return ComparisonOperatorExists, nil
	case "GT":
		return ComparisonOperatorGt, nil
	case "GTE":
		return ComparisonOperatorGte, nil
	case "INCLUDES":
		return ComparisonOperatorIncludes, nil
	case "IS_AFTER":
		return ComparisonOperatorIsAfter, nil
	case "IS_BEFORE":
		return ComparisonOperatorIsBefore, nil
	case "LT":
		return ComparisonOperatorLt, nil
	case "LTE":
		return ComparisonOperatorLte, nil
	case "NEQ":
		return ComparisonOperatorNeq, nil
	case "OMIT":
		return ComparisonOperatorOmit, nil
	case "STARTS_WITH":
		return ComparisonOperatorStartsWith, nil
	}
	var t ComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComparisonOperator) Ptr() *ComparisonOperator {
	return &c
}

type FilterConfig struct {
	typeName           string
	SingleFilterConfig *SingleFilterConfig
	NestedFilterConfig *NestedFilterConfig
}

func NewFilterConfigFromSingleFilterConfig(value *SingleFilterConfig) *FilterConfig {
	return &FilterConfig{typeName: "singleFilterConfig", SingleFilterConfig: value}
}

func NewFilterConfigFromNestedFilterConfig(value *NestedFilterConfig) *FilterConfig {
	return &FilterConfig{typeName: "nestedFilterConfig", NestedFilterConfig: value}
}

func (f *FilterConfig) UnmarshalJSON(data []byte) error {
	valueSingleFilterConfig := new(SingleFilterConfig)
	if err := json.Unmarshal(data, &valueSingleFilterConfig); err == nil {
		f.typeName = "singleFilterConfig"
		f.SingleFilterConfig = valueSingleFilterConfig
		return nil
	}
	valueNestedFilterConfig := new(NestedFilterConfig)
	if err := json.Unmarshal(data, &valueNestedFilterConfig); err == nil {
		f.typeName = "nestedFilterConfig"
		f.NestedFilterConfig = valueNestedFilterConfig
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterConfig) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "singleFilterConfig":
		return json.Marshal(f.SingleFilterConfig)
	case "nestedFilterConfig":
		return json.Marshal(f.NestedFilterConfig)
	}
}

type FilterConfigVisitor interface {
	VisitSingleFilterConfig(*SingleFilterConfig) error
	VisitNestedFilterConfig(*NestedFilterConfig) error
}

func (f *FilterConfig) Accept(visitor FilterConfigVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "singleFilterConfig":
		return visitor.VisitSingleFilterConfig(f.SingleFilterConfig)
	case "nestedFilterConfig":
		return visitor.VisitNestedFilterConfig(f.NestedFilterConfig)
	}
}

type LogicalOperator string

const (
	LogicalOperatorAnd LogicalOperator = "AND"
	LogicalOperatorOr  LogicalOperator = "OR"
)

func NewLogicalOperatorFromString(s string) (LogicalOperator, error) {
	switch s {
	case "AND":
		return LogicalOperatorAnd, nil
	case "OR":
		return LogicalOperatorOr, nil
	}
	var t LogicalOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogicalOperator) Ptr() *LogicalOperator {
	return &l
}

// The operator to use for filtering
type NestedFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator       `json:"operator,omitempty"`
	Rules    []*FilterConfig `json:"rules,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NestedFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NestedFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NestedFilterConfig(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NestedFilterConfig) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Operator struct {
	typeName           string
	ComparisonOperator ComparisonOperator
	LogicalOperator    LogicalOperator
}

func NewOperatorFromComparisonOperator(value ComparisonOperator) *Operator {
	return &Operator{typeName: "comparisonOperator", ComparisonOperator: value}
}

func NewOperatorFromLogicalOperator(value LogicalOperator) *Operator {
	return &Operator{typeName: "logicalOperator", LogicalOperator: value}
}

func (o *Operator) UnmarshalJSON(data []byte) error {
	var valueComparisonOperator ComparisonOperator
	if err := json.Unmarshal(data, &valueComparisonOperator); err == nil {
		o.typeName = "comparisonOperator"
		o.ComparisonOperator = valueComparisonOperator
		return nil
	}
	var valueLogicalOperator LogicalOperator
	if err := json.Unmarshal(data, &valueLogicalOperator); err == nil {
		o.typeName = "logicalOperator"
		o.LogicalOperator = valueLogicalOperator
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o Operator) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "comparisonOperator":
		return json.Marshal(o.ComparisonOperator)
	case "logicalOperator":
		return json.Marshal(o.LogicalOperator)
	}
}

type OperatorVisitor interface {
	VisitComparisonOperator(ComparisonOperator) error
	VisitLogicalOperator(LogicalOperator) error
}

func (o *Operator) Accept(visitor OperatorVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "comparisonOperator":
		return visitor.VisitComparisonOperator(o.ComparisonOperator)
	case "logicalOperator":
		return visitor.VisitLogicalOperator(o.LogicalOperator)
	}
}

// A single filter to use for filtering
type SingleFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator `json:"operator,omitempty"`
	// The value to use for filtering
	Value string `json:"value"`
	// The attribe name from profile whose value will be operated against the filter value
	Path string `json:"path"`

	_rawJSON json.RawMessage
}

func (s *SingleFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleFilterConfig(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleFilterConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Actor struct {
	Id    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	type unmarshaler Actor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actor(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Actor) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type GetAuditEventParams struct {
	AuditEventId string `json:"auditEventId"`

	_rawJSON json.RawMessage
}

func (g *GetAuditEventParams) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAuditEventParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAuditEventParams(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAuditEventParams) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAuditEventsParams struct {
	Cursor *string `json:"cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListAuditEventsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAuditEventsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAuditEventsParams(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAuditEventsParams) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Target struct {
	Id    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Target) UnmarshalJSON(data []byte) error {
	type unmarshaler Target
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Target(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Target) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Automation struct {
	CancelationToken *string                 `json:"cancelation_token,omitempty"`
	Steps            []*AutomationStepOption `json:"steps,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Automation) UnmarshalJSON(data []byte) error {
	type unmarshaler Automation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Automation(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Automation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationCancelStep struct {
	If               *string `json:"if,omitempty"`
	Ref              *string `json:"ref,omitempty"`
	CancelationToken *string `json:"cancelation_token,omitempty"`
	action           string

	_rawJSON json.RawMessage
}

func (a *AutomationCancelStep) Action() string {
	return a.action
}

func (a *AutomationCancelStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationCancelStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationCancelStep(value)
	a.action = "cancel"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationCancelStep) MarshalJSON() ([]byte, error) {
	type embed AutomationCancelStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "cancel",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationCancelStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationDelayStep struct {
	If     *string `json:"if,omitempty"`
	Ref    *string `json:"ref,omitempty"`
	Until  *string `json:"until,omitempty"`
	action string

	_rawJSON json.RawMessage
}

func (a *AutomationDelayStep) Action() string {
	return a.action
}

func (a *AutomationDelayStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationDelayStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationDelayStep(value)
	a.action = "delay"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationDelayStep) MarshalJSON() ([]byte, error) {
	type embed AutomationDelayStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "delay",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationDelayStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationInvokeStep struct {
	If       *string `json:"if,omitempty"`
	Ref      *string `json:"ref,omitempty"`
	Template string  `json:"template"`
	action   string

	_rawJSON json.RawMessage
}

func (a *AutomationInvokeStep) Action() string {
	return a.action
}

func (a *AutomationInvokeStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationInvokeStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationInvokeStep(value)
	a.action = "invoke"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationInvokeStep) MarshalJSON() ([]byte, error) {
	type embed AutomationInvokeStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "invoke",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationInvokeStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationInvokeTemplateParams struct {
	Brand      *string                `json:"brand,omitempty"`
	Data       map[string]interface{} `json:"data,omitempty"`
	Profile    *Profile               `json:"profile,omitempty"`
	Recipient  *string                `json:"recipient,omitempty"`
	Template   *string                `json:"template,omitempty"`
	TemplateId string                 `json:"templateId"`

	_rawJSON json.RawMessage
}

func (a *AutomationInvokeTemplateParams) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationInvokeTemplateParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationInvokeTemplateParams(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationInvokeTemplateParams) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationRunContext struct {
	Brand     *string     `json:"brand,omitempty"`
	Data      interface{} `json:"data,omitempty"`
	Profile   *Profile    `json:"profile,omitempty"`
	Template  *string     `json:"template,omitempty"`
	Recipient *string     `json:"recipient,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AutomationRunContext) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationRunContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationRunContext(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationRunContext) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationSendListStep struct {
	If       *string                `json:"if,omitempty"`
	Ref      *string                `json:"ref,omitempty"`
	Brand    *string                `json:"brand,omitempty"`
	Data     map[string]interface{} `json:"data,omitempty"`
	List     string                 `json:"list"`
	Override map[string]interface{} `json:"override,omitempty"`
	Template *string                `json:"template,omitempty"`
	action   string

	_rawJSON json.RawMessage
}

func (a *AutomationSendListStep) Action() string {
	return a.action
}

func (a *AutomationSendListStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationSendListStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationSendListStep(value)
	a.action = "send-list"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationSendListStep) MarshalJSON() ([]byte, error) {
	type embed AutomationSendListStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "send-list",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationSendListStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationSendStep struct {
	If        *string                `json:"if,omitempty"`
	Ref       *string                `json:"ref,omitempty"`
	Brand     *string                `json:"brand,omitempty"`
	Data      map[string]interface{} `json:"data,omitempty"`
	Override  map[string]interface{} `json:"override,omitempty"`
	Profile   interface{}            `json:"profile,omitempty"`
	Recipient *string                `json:"recipient,omitempty"`
	Template  *string                `json:"template,omitempty"`
	action    string

	_rawJSON json.RawMessage
}

func (a *AutomationSendStep) Action() string {
	return a.action
}

func (a *AutomationSendStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationSendStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationSendStep(value)
	a.action = "send"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationSendStep) MarshalJSON() ([]byte, error) {
	type embed AutomationSendStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "send",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationSendStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationStep struct {
	If  *string `json:"if,omitempty"`
	Ref *string `json:"ref,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AutomationStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationStep(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationStepAction string

const (
	AutomationStepActionCancel        AutomationStepAction = "cancel"
	AutomationStepActionDelay         AutomationStepAction = "delay"
	AutomationStepActionInvoke        AutomationStepAction = "invoke"
	AutomationStepActionSend          AutomationStepAction = "send"
	AutomationStepActionSendList      AutomationStepAction = "send-list"
	AutomationStepActionUpdateProfile AutomationStepAction = "update-profile"
)

func NewAutomationStepActionFromString(s string) (AutomationStepAction, error) {
	switch s {
	case "cancel":
		return AutomationStepActionCancel, nil
	case "delay":
		return AutomationStepActionDelay, nil
	case "invoke":
		return AutomationStepActionInvoke, nil
	case "send":
		return AutomationStepActionSend, nil
	case "send-list":
		return AutomationStepActionSendList, nil
	case "update-profile":
		return AutomationStepActionUpdateProfile, nil
	}
	var t AutomationStepAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AutomationStepAction) Ptr() *AutomationStepAction {
	return &a
}

type AutomationStepOption struct {
	typeName                    string
	AutomationCancelStep        *AutomationCancelStep
	AutomationDelayStep         *AutomationDelayStep
	AutomationInvokeStep        *AutomationInvokeStep
	AutomationSendStep          *AutomationSendStep
	AutomationV2SendStep        *AutomationV2SendStep
	AutomationSendListStep      *AutomationSendListStep
	AutomationUpdateProfileStep *AutomationUpdateProfileStep
}

func NewAutomationStepOptionFromAutomationCancelStep(value *AutomationCancelStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationCancelStep", AutomationCancelStep: value}
}

func NewAutomationStepOptionFromAutomationDelayStep(value *AutomationDelayStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationDelayStep", AutomationDelayStep: value}
}

func NewAutomationStepOptionFromAutomationInvokeStep(value *AutomationInvokeStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationInvokeStep", AutomationInvokeStep: value}
}

func NewAutomationStepOptionFromAutomationSendStep(value *AutomationSendStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationSendStep", AutomationSendStep: value}
}

func NewAutomationStepOptionFromAutomationV2SendStep(value *AutomationV2SendStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationV2SendStep", AutomationV2SendStep: value}
}

func NewAutomationStepOptionFromAutomationSendListStep(value *AutomationSendListStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationSendListStep", AutomationSendListStep: value}
}

func NewAutomationStepOptionFromAutomationUpdateProfileStep(value *AutomationUpdateProfileStep) *AutomationStepOption {
	return &AutomationStepOption{typeName: "automationUpdateProfileStep", AutomationUpdateProfileStep: value}
}

func (a *AutomationStepOption) UnmarshalJSON(data []byte) error {
	valueAutomationCancelStep := new(AutomationCancelStep)
	if err := json.Unmarshal(data, &valueAutomationCancelStep); err == nil {
		a.typeName = "automationCancelStep"
		a.AutomationCancelStep = valueAutomationCancelStep
		return nil
	}
	valueAutomationDelayStep := new(AutomationDelayStep)
	if err := json.Unmarshal(data, &valueAutomationDelayStep); err == nil {
		a.typeName = "automationDelayStep"
		a.AutomationDelayStep = valueAutomationDelayStep
		return nil
	}
	valueAutomationInvokeStep := new(AutomationInvokeStep)
	if err := json.Unmarshal(data, &valueAutomationInvokeStep); err == nil {
		a.typeName = "automationInvokeStep"
		a.AutomationInvokeStep = valueAutomationInvokeStep
		return nil
	}
	valueAutomationSendStep := new(AutomationSendStep)
	if err := json.Unmarshal(data, &valueAutomationSendStep); err == nil {
		a.typeName = "automationSendStep"
		a.AutomationSendStep = valueAutomationSendStep
		return nil
	}
	valueAutomationV2SendStep := new(AutomationV2SendStep)
	if err := json.Unmarshal(data, &valueAutomationV2SendStep); err == nil {
		a.typeName = "automationV2SendStep"
		a.AutomationV2SendStep = valueAutomationV2SendStep
		return nil
	}
	valueAutomationSendListStep := new(AutomationSendListStep)
	if err := json.Unmarshal(data, &valueAutomationSendListStep); err == nil {
		a.typeName = "automationSendListStep"
		a.AutomationSendListStep = valueAutomationSendListStep
		return nil
	}
	valueAutomationUpdateProfileStep := new(AutomationUpdateProfileStep)
	if err := json.Unmarshal(data, &valueAutomationUpdateProfileStep); err == nil {
		a.typeName = "automationUpdateProfileStep"
		a.AutomationUpdateProfileStep = valueAutomationUpdateProfileStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AutomationStepOption) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "automationCancelStep":
		return json.Marshal(a.AutomationCancelStep)
	case "automationDelayStep":
		return json.Marshal(a.AutomationDelayStep)
	case "automationInvokeStep":
		return json.Marshal(a.AutomationInvokeStep)
	case "automationSendStep":
		return json.Marshal(a.AutomationSendStep)
	case "automationV2SendStep":
		return json.Marshal(a.AutomationV2SendStep)
	case "automationSendListStep":
		return json.Marshal(a.AutomationSendListStep)
	case "automationUpdateProfileStep":
		return json.Marshal(a.AutomationUpdateProfileStep)
	}
}

type AutomationStepOptionVisitor interface {
	VisitAutomationCancelStep(*AutomationCancelStep) error
	VisitAutomationDelayStep(*AutomationDelayStep) error
	VisitAutomationInvokeStep(*AutomationInvokeStep) error
	VisitAutomationSendStep(*AutomationSendStep) error
	VisitAutomationV2SendStep(*AutomationV2SendStep) error
	VisitAutomationSendListStep(*AutomationSendListStep) error
	VisitAutomationUpdateProfileStep(*AutomationUpdateProfileStep) error
}

func (a *AutomationStepOption) Accept(visitor AutomationStepOptionVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "automationCancelStep":
		return visitor.VisitAutomationCancelStep(a.AutomationCancelStep)
	case "automationDelayStep":
		return visitor.VisitAutomationDelayStep(a.AutomationDelayStep)
	case "automationInvokeStep":
		return visitor.VisitAutomationInvokeStep(a.AutomationInvokeStep)
	case "automationSendStep":
		return visitor.VisitAutomationSendStep(a.AutomationSendStep)
	case "automationV2SendStep":
		return visitor.VisitAutomationV2SendStep(a.AutomationV2SendStep)
	case "automationSendListStep":
		return visitor.VisitAutomationSendListStep(a.AutomationSendListStep)
	case "automationUpdateProfileStep":
		return visitor.VisitAutomationUpdateProfileStep(a.AutomationUpdateProfileStep)
	}
}

type AutomationUpdateProfileStep struct {
	RecipientId string         `json:"recipient_id"`
	Profile     Profile        `json:"profile,omitempty"`
	Merge       MergeAlgorithm `json:"merge,omitempty"`
	action      string

	_rawJSON json.RawMessage
}

func (a *AutomationUpdateProfileStep) Action() string {
	return a.action
}

func (a *AutomationUpdateProfileStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationUpdateProfileStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationUpdateProfileStep(value)
	a.action = "update-profile"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationUpdateProfileStep) MarshalJSON() ([]byte, error) {
	type embed AutomationUpdateProfileStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "update-profile",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationUpdateProfileStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomationV2SendStep struct {
	If      *string  `json:"if,omitempty"`
	Ref     *string  `json:"ref,omitempty"`
	Message *Message `json:"message,omitempty"`
	action  string

	_rawJSON json.RawMessage
}

func (a *AutomationV2SendStep) Action() string {
	return a.action
}

func (a *AutomationV2SendStep) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomationV2SendStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomationV2SendStep(value)
	a.action = "send"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomationV2SendStep) MarshalJSON() ([]byte, error) {
	type embed AutomationV2SendStep
	var marshaler = struct {
		embed
		Action string `json:"action"`
	}{
		embed:  embed(*a),
		Action: "send",
	}
	return json.Marshal(marshaler)
}

func (a *AutomationV2SendStep) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type MergeAlgorithm string

const (
	MergeAlgorithmReplace   MergeAlgorithm = "replace"
	MergeAlgorithmNone      MergeAlgorithm = "none"
	MergeAlgorithmOverwrite MergeAlgorithm = "overwrite"
	MergeAlgorithmSoftMerge MergeAlgorithm = "soft-merge"
)

func NewMergeAlgorithmFromString(s string) (MergeAlgorithm, error) {
	switch s {
	case "replace":
		return MergeAlgorithmReplace, nil
	case "none":
		return MergeAlgorithmNone, nil
	case "overwrite":
		return MergeAlgorithmOverwrite, nil
	case "soft-merge":
		return MergeAlgorithmSoftMerge, nil
	}
	var t MergeAlgorithm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MergeAlgorithm) Ptr() *MergeAlgorithm {
	return &m
}

type Profile = interface{}

type BrandColors struct {
	Primary   *string `json:"primary,omitempty"`
	Secondary *string `json:"secondary,omitempty"`
	Tertiary  *string `json:"tertiary,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandColors) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandColors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandColors(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandColors) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandGetAllResponse struct {
	Paging  *Paging  `json:"paging,omitempty"`
	Results []*Brand `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandGetAllResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandGetAllResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandGetAllResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandGetAllResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSnippet struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	format string

	_rawJSON json.RawMessage
}

func (b *BrandSnippet) Format() string {
	return b.format
}

func (b *BrandSnippet) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSnippet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSnippet(value)
	b.format = "handlebars"
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSnippet) MarshalJSON() ([]byte, error) {
	type embed BrandSnippet
	var marshaler = struct {
		embed
		Format string `json:"format"`
	}{
		embed:  embed(*b),
		Format: "handlebars",
	}
	return json.Marshal(marshaler)
}

func (b *BrandSnippet) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkGetJobParams struct {
	JobId string `json:"jobId"`

	_rawJSON json.RawMessage
}

func (b *BulkGetJobParams) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkGetJobParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkGetJobParams(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkGetJobParams) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkGetJobUsersParams struct {
	JobId  string  `json:"jobId"`
	Cursor *string `json:"cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkGetJobUsersParams) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkGetJobUsersParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkGetJobUsersParams(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkGetJobUsersParams) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkIngestError struct {
	User  interface{} `json:"user,omitempty"`
	Error interface{} `json:"error,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkIngestError) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkIngestError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkIngestError(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkIngestError) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkIngestUsersResponse struct {
	Total  int                `json:"total"`
	Errors []*BulkIngestError `json:"errors,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkIngestUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkIngestUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkIngestUsersResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkIngestUsersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkJobStatus string

const (
	BulkJobStatusCreated    BulkJobStatus = "CREATED"
	BulkJobStatusProcessing BulkJobStatus = "PROCESSING"
	BulkJobStatusCompleted  BulkJobStatus = "COMPLETED"
	BulkJobStatusError      BulkJobStatus = "ERROR"
)

func NewBulkJobStatusFromString(s string) (BulkJobStatus, error) {
	switch s {
	case "CREATED":
		return BulkJobStatusCreated, nil
	case "PROCESSING":
		return BulkJobStatusProcessing, nil
	case "COMPLETED":
		return BulkJobStatusCompleted, nil
	case "ERROR":
		return BulkJobStatusError, nil
	}
	var t BulkJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkJobStatus) Ptr() *BulkJobStatus {
	return &b
}

type BulkJobUserStatus string

const (
	BulkJobUserStatusPending  BulkJobUserStatus = "PENDING"
	BulkJobUserStatusEnqueued BulkJobUserStatus = "ENQUEUED"
	BulkJobUserStatusError    BulkJobUserStatus = "ERROR"
)

func NewBulkJobUserStatusFromString(s string) (BulkJobUserStatus, error) {
	switch s {
	case "PENDING":
		return BulkJobUserStatusPending, nil
	case "ENQUEUED":
		return BulkJobUserStatusEnqueued, nil
	case "ERROR":
		return BulkJobUserStatusError, nil
	}
	var t BulkJobUserStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkJobUserStatus) Ptr() *BulkJobUserStatus {
	return &b
}

type BulkMessageUserResponse struct {
	Preferences *RecipientPreferences `json:"preferences,omitempty"`
	Profile     interface{}           `json:"profile,omitempty"`
	Recipient   *string               `json:"recipient,omitempty"`
	Data        interface{}           `json:"data,omitempty"`
	To          *UserRecipient        `json:"to,omitempty"`
	Status      BulkJobUserStatus     `json:"status,omitempty"`
	MessageId   *string               `json:"messageId,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkMessageUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkMessageUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkMessageUserResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkMessageUserResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The message property has the following primary top-level properties. They define the destination and content of the message.
// Additional advanced configuration fields [are defined below](https://www.courier.com/docs/reference/send/message/#other-message-properties).
type InboundBulkContentMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata *MessageMetadata `json:"metadata,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Defines the time to wait before delivering the message.
	Delay *Delay `json:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty"`
	// Describes the content of the message in a way that will work for email, push,
	// chat, or any channel. Either this or template must be specified.
	Content *Content `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InboundBulkContentMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler InboundBulkContentMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboundBulkContentMessage(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboundBulkContentMessage) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboundBulkMessageUser struct {
	Preferences *RecipientPreferences `json:"preferences,omitempty"`
	Profile     interface{}           `json:"profile,omitempty"`
	Recipient   *string               `json:"recipient,omitempty"`
	Data        interface{}           `json:"data,omitempty"`
	To          *UserRecipient        `json:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InboundBulkMessageUser) UnmarshalJSON(data []byte) error {
	type unmarshaler InboundBulkMessageUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboundBulkMessageUser(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboundBulkMessageUser) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboundBulkMessageV1 struct {
	// A unique identifier that represents the brand that should be used
	// for rendering the notification.
	Brand *string `json:"brand,omitempty"`
	// JSON that includes any data you want to pass to a message template.
	// The data will populate the corresponding template variables.
	Data   map[string]interface{} `json:"data,omitempty"`
	Event  *string                `json:"event,omitempty"`
	Locale map[string]interface{} `json:"locale,omitempty"`
	// JSON that is merged into the request sent by Courier to the provider
	// to override properties or to gain access to features in the provider
	// API that are not natively supported by Courier.
	Override interface{} `json:"override,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InboundBulkMessageV1) UnmarshalJSON(data []byte) error {
	type unmarshaler InboundBulkMessageV1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboundBulkMessageV1(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboundBulkMessageV1) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboundBulkMessageV2 struct {
	typeName string
	// Describes the content of the message in a way that will
	// work for email, push, chat, or any channel.
	InboundBulkTemplateMessage *InboundBulkTemplateMessage
	// A template for a type of message that can be sent more than once.
	// For example, you might create an "Appointment Reminder" Notification or
	// “Reset Password” Notifications.
	InboundBulkContentMessage *InboundBulkContentMessage
}

func NewInboundBulkMessageV2FromInboundBulkTemplateMessage(value *InboundBulkTemplateMessage) *InboundBulkMessageV2 {
	return &InboundBulkMessageV2{typeName: "inboundBulkTemplateMessage", InboundBulkTemplateMessage: value}
}

func NewInboundBulkMessageV2FromInboundBulkContentMessage(value *InboundBulkContentMessage) *InboundBulkMessageV2 {
	return &InboundBulkMessageV2{typeName: "inboundBulkContentMessage", InboundBulkContentMessage: value}
}

func (i *InboundBulkMessageV2) UnmarshalJSON(data []byte) error {
	valueInboundBulkTemplateMessage := new(InboundBulkTemplateMessage)
	if err := json.Unmarshal(data, &valueInboundBulkTemplateMessage); err == nil {
		i.typeName = "inboundBulkTemplateMessage"
		i.InboundBulkTemplateMessage = valueInboundBulkTemplateMessage
		return nil
	}
	valueInboundBulkContentMessage := new(InboundBulkContentMessage)
	if err := json.Unmarshal(data, &valueInboundBulkContentMessage); err == nil {
		i.typeName = "inboundBulkContentMessage"
		i.InboundBulkContentMessage = valueInboundBulkContentMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InboundBulkMessageV2) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "inboundBulkTemplateMessage":
		return json.Marshal(i.InboundBulkTemplateMessage)
	case "inboundBulkContentMessage":
		return json.Marshal(i.InboundBulkContentMessage)
	}
}

type InboundBulkMessageV2Visitor interface {
	VisitInboundBulkTemplateMessage(*InboundBulkTemplateMessage) error
	VisitInboundBulkContentMessage(*InboundBulkContentMessage) error
}

func (i *InboundBulkMessageV2) Accept(visitor InboundBulkMessageV2Visitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "inboundBulkTemplateMessage":
		return visitor.VisitInboundBulkTemplateMessage(i.InboundBulkTemplateMessage)
	case "inboundBulkContentMessage":
		return visitor.VisitInboundBulkContentMessage(i.InboundBulkContentMessage)
	}
}

type InboundBulkTemplateMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata *MessageMetadata `json:"metadata,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Defines the time to wait before delivering the message.
	Delay *Delay `json:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty"`
	// The id of the notification template to be rendered and sent to the recipient(s).
	// This field or the content field must be supplied.
	Template string `json:"template"`

	_rawJSON json.RawMessage
}

func (i *InboundBulkTemplateMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler InboundBulkTemplateMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboundBulkTemplateMessage(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboundBulkTemplateMessage) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JobDetails struct {
	Definition *InboundBulkMessage `json:"definition,omitempty"`
	Enqueued   int                 `json:"enqueued"`
	Failures   int                 `json:"failures"`
	Received   int                 `json:"received"`
	Status     BulkJobStatus       `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler JobDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobDetails(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobDetails) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type AlreadyExists struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (a *AlreadyExists) Type() string {
	return a.type_
}

func (a *AlreadyExists) UnmarshalJSON(data []byte) error {
	type unmarshaler AlreadyExists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlreadyExists(value)
	a.type_ = "invalid_request_error"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlreadyExists) MarshalJSON() ([]byte, error) {
	type embed AlreadyExists
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (a *AlreadyExists) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BadRequest struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (b *BadRequest) Type() string {
	return b.type_
}

func (b *BadRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BadRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BadRequest(value)
	b.type_ = "invalid_request_error"
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BadRequest) MarshalJSON() ([]byte, error) {
	type embed BadRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (b *BadRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseError struct {
	// A message describing the error that occurred.
	Message string `json:"message"`

	_rawJSON json.RawMessage
}

func (b *BaseError) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseError(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseError) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ChannelClassification string

const (
	ChannelClassificationDirectMessage ChannelClassification = "direct_message"
	ChannelClassificationEmail         ChannelClassification = "email"
	ChannelClassificationPush          ChannelClassification = "push"
	ChannelClassificationSms           ChannelClassification = "sms"
	ChannelClassificationWebhook       ChannelClassification = "webhook"
	ChannelClassificationInbox         ChannelClassification = "inbox"
)

func NewChannelClassificationFromString(s string) (ChannelClassification, error) {
	switch s {
	case "direct_message":
		return ChannelClassificationDirectMessage, nil
	case "email":
		return ChannelClassificationEmail, nil
	case "push":
		return ChannelClassificationPush, nil
	case "sms":
		return ChannelClassificationSms, nil
	case "webhook":
		return ChannelClassificationWebhook, nil
	case "inbox":
		return ChannelClassificationInbox, nil
	}
	var t ChannelClassification
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChannelClassification) Ptr() *ChannelClassification {
	return &c
}

type ChannelPreference struct {
	Channel ChannelClassification `json:"channel,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChannelPreference) UnmarshalJSON(data []byte) error {
	type unmarshaler ChannelPreference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChannelPreference(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChannelPreference) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Conflict struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (c *Conflict) Type() string {
	return c.type_
}

func (c *Conflict) UnmarshalJSON(data []byte) error {
	type unmarshaler Conflict
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Conflict(value)
	c.type_ = "invalid_request_error"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Conflict) MarshalJSON() ([]byte, error) {
	type embed Conflict
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (c *Conflict) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Email struct {
	Footer interface{} `json:"footer,omitempty"`
	Header interface{} `json:"header,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Email) UnmarshalJSON(data []byte) error {
	type unmarshaler Email
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Email(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Email) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MessageNotFound struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (m *MessageNotFound) Type() string {
	return m.type_
}

func (m *MessageNotFound) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageNotFound
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageNotFound(value)
	m.type_ = "invalid_request_error"
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageNotFound) MarshalJSON() ([]byte, error) {
	type embed MessageNotFound
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (m *MessageNotFound) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NotFound struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (n *NotFound) Type() string {
	return n.type_
}

func (n *NotFound) UnmarshalJSON(data []byte) error {
	type unmarshaler NotFound
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotFound(value)
	n.type_ = "invalid_request_error"
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotFound) MarshalJSON() ([]byte, error) {
	type embed NotFound
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*n),
		Type:  "invalid_request_error",
	}
	return json.Marshal(marshaler)
}

func (n *NotFound) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPreferenceDetails struct {
	Status             PreferenceStatus     `json:"status,omitempty"`
	Rules              []*Rule              `json:"rules,omitempty"`
	ChannelPreferences []*ChannelPreference `json:"channel_preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotificationPreferenceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPreferenceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPreferenceDetails(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPreferenceDetails) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPreferences = map[string]*NotificationPreferenceDetails

type Paging struct {
	Cursor *string `json:"cursor,omitempty"`
	More   bool    `json:"more"`

	_rawJSON json.RawMessage
}

func (p *Paging) UnmarshalJSON(data []byte) error {
	type unmarshaler Paging
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Paging(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Paging) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRequired struct {
	// A message describing the error that occurred.
	Message string `json:"message"`
	type_   string

	_rawJSON json.RawMessage
}

func (p *PaymentRequired) Type() string {
	return p.type_
}

func (p *PaymentRequired) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRequired
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRequired(value)
	p.type_ = "authorization_error"
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRequired) MarshalJSON() ([]byte, error) {
	type embed PaymentRequired
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "authorization_error",
	}
	return json.Marshal(marshaler)
}

func (p *PaymentRequired) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PreferenceStatus string

const (
	PreferenceStatusOptedIn  PreferenceStatus = "OPTED_IN"
	PreferenceStatusOptedOut PreferenceStatus = "OPTED_OUT"
	PreferenceStatusRequired PreferenceStatus = "REQUIRED"
)

func NewPreferenceStatusFromString(s string) (PreferenceStatus, error) {
	switch s {
	case "OPTED_IN":
		return PreferenceStatusOptedIn, nil
	case "OPTED_OUT":
		return PreferenceStatusOptedOut, nil
	case "REQUIRED":
		return PreferenceStatusRequired, nil
	}
	var t PreferenceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreferenceStatus) Ptr() *PreferenceStatus {
	return &p
}

type Rule struct {
	Start *string `json:"start,omitempty"`
	Until string  `json:"until"`

	_rawJSON json.RawMessage
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	type unmarshaler Rule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Rule(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Rule) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type UserTenantAssociation struct {
	// User ID for the assocation between tenant and user
	UserId string `json:"user_id"`
	// Tenant ID for the assocation between tenant and user
	TenantId string                 `json:"tenant_id"`
	Profile  map[string]interface{} `json:"profile,omitempty"`
	type_    string

	_rawJSON json.RawMessage
}

func (u *UserTenantAssociation) Type() string {
	return u.type_
}

func (u *UserTenantAssociation) UnmarshalJSON(data []byte) error {
	type unmarshaler UserTenantAssociation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserTenantAssociation(value)
	u.type_ = "user"
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserTenantAssociation) MarshalJSON() ([]byte, error) {
	type embed UserTenantAssociation
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "user",
	}
	return json.Marshal(marshaler)
}

func (u *UserTenantAssociation) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ListSubscriptionRecipient struct {
	RecipientId string                `json:"recipientId"`
	Created     *string               `json:"created,omitempty"`
	Preferences *RecipientPreferences `json:"preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListSubscriptionRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSubscriptionRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSubscriptionRecipient(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSubscriptionRecipient) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MessageStatus string

const (
	// The recipient has clicked on any link in the message at least one time.
	MessageStatusClicked MessageStatus = "CLICKED"
	// The provider successfully delivered the message to the recipient.
	MessageStatusDelivered MessageStatus = "DELIVERED"
	// The request has been received to send a message, is waiting in the work queue.
	MessageStatusEnqueued MessageStatus = "ENQUEUED"
	// The recipient has opened the message at least one time.
	MessageStatusOpened MessageStatus = "OPENED"
	// The message has been canceled such that it will not be delivered.
	MessageStatusCanceled MessageStatus = "CANCELED"
	// The message has been accepted by the provider.
	MessageStatusSent MessageStatus = "SENT"
	// The message could not be delivered to at least one provider, or the provider could not deliver the message to the recipient. This can happen for multiple reasons: an error, insufficient profile data, invalid notification setup, invalid integration configuration, etc.
	MessageStatusUndeliverable MessageStatus = "UNDELIVERABLE"
	// Could not find a corresponding notification or event for the messages.
	MessageStatusUnmapped MessageStatus = "UNMAPPED"
	// The message could not be routed to any channel or provider. This can happen for multiple reasons: insufficient profile data, invalid notification setup, invalid integration configuration, etc.
	MessageStatusUnroutable MessageStatus = "UNROUTABLE"
)

func NewMessageStatusFromString(s string) (MessageStatus, error) {
	switch s {
	case "CLICKED":
		return MessageStatusClicked, nil
	case "DELIVERED":
		return MessageStatusDelivered, nil
	case "ENQUEUED":
		return MessageStatusEnqueued, nil
	case "OPENED":
		return MessageStatusOpened, nil
	case "CANCELED":
		return MessageStatusCanceled, nil
	case "SENT":
		return MessageStatusSent, nil
	case "UNDELIVERABLE":
		return MessageStatusUndeliverable, nil
	case "UNMAPPED":
		return MessageStatusUnmapped, nil
	case "UNROUTABLE":
		return MessageStatusUnroutable, nil
	}
	var t MessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MessageStatus) Ptr() *MessageStatus {
	return &m
}

type Reason string

const (
	// The recipient did not receive the notification because of a condition that passed.
	ReasonFiltered Reason = "FILTERED"
	// The notification did not contain any valid channels.
	ReasonNoChannels Reason = "NO_CHANNELS"
	// The notification did not contain a configured provider for a channel.
	ReasonNoProviders Reason = "NO_PROVIDERS"
	// The Integration provider had an error when sending a notification.
	ReasonProviderError Reason = "PROVIDER_ERROR"
	// The notification hasn't been published yet.
	ReasonUnpublished Reason = "UNPUBLISHED"
	// The recipient did not receive the notification because they chose to unsubscribe from it.
	ReasonUnsubscribed Reason = "UNSUBSCRIBED"
)

func NewReasonFromString(s string) (Reason, error) {
	switch s {
	case "FILTERED":
		return ReasonFiltered, nil
	case "NO_CHANNELS":
		return ReasonNoChannels, nil
	case "NO_PROVIDERS":
		return ReasonNoProviders, nil
	case "PROVIDER_ERROR":
		return ReasonProviderError, nil
	case "UNPUBLISHED":
		return ReasonUnpublished, nil
	case "UNSUBSCRIBED":
		return ReasonUnsubscribed, nil
	}
	var t Reason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Reason) Ptr() *Reason {
	return &r
}

type RenderOutput struct {
	// The channel used for rendering the message.
	Channel string `json:"channel"`
	// The ID of channel used for rendering the message.
	ChannelId string `json:"channel_id"`
	// Content details of the rendered message.
	Content *RenderedMessageContent `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RenderOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler RenderOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RenderOutput(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RenderOutput) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RenderedMessageBlock struct {
	// The block type of the rendered message block.
	Type string `json:"type"`
	// The block text of the rendered message block.
	Text string `json:"text"`

	_rawJSON json.RawMessage
}

func (r *RenderedMessageBlock) UnmarshalJSON(data []byte) error {
	type unmarshaler RenderedMessageBlock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RenderedMessageBlock(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RenderedMessageBlock) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RenderedMessageContent struct {
	// The html content of the rendered message.
	Html string `json:"html"`
	// The title of the rendered message.
	Title string `json:"title"`
	// The body of the rendered message.
	Body string `json:"body"`
	// The subject of the rendered message.
	Subject string `json:"subject"`
	// The text of the rendered message.
	Text string `json:"text"`
	// The blocks of the rendered message.
	Blocks []*RenderedMessageBlock `json:"blocks,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RenderedMessageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler RenderedMessageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RenderedMessageContent(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RenderedMessageContent) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BlockType string

const (
	BlockTypeAction   BlockType = "action"
	BlockTypeDivider  BlockType = "divider"
	BlockTypeImage    BlockType = "image"
	BlockTypeJsonnet  BlockType = "jsonnet"
	BlockTypeList     BlockType = "list"
	BlockTypeMarkdown BlockType = "markdown"
	BlockTypeQuote    BlockType = "quote"
	BlockTypeTemplate BlockType = "template"
	BlockTypeText     BlockType = "text"
)

func NewBlockTypeFromString(s string) (BlockType, error) {
	switch s {
	case "action":
		return BlockTypeAction, nil
	case "divider":
		return BlockTypeDivider, nil
	case "image":
		return BlockTypeImage, nil
	case "jsonnet":
		return BlockTypeJsonnet, nil
	case "list":
		return BlockTypeList, nil
	case "markdown":
		return BlockTypeMarkdown, nil
	case "quote":
		return BlockTypeQuote, nil
	case "template":
		return BlockTypeTemplate, nil
	case "text":
		return BlockTypeText, nil
	}
	var t BlockType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BlockType) Ptr() *BlockType {
	return &b
}

type Check struct {
	Id      string      `json:"id"`
	Status  CheckStatus `json:"status,omitempty"`
	Updated int64       `json:"updated"`
	type_   string

	_rawJSON json.RawMessage
}

func (c *Check) Type() string {
	return c.type_
}

func (c *Check) UnmarshalJSON(data []byte) error {
	type unmarshaler Check
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Check(value)
	c.type_ = "custom"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Check) MarshalJSON() ([]byte, error) {
	type embed Check
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "custom",
	}
	return json.Marshal(marshaler)
}

func (c *Check) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckStatus string

const (
	CheckStatusResolved CheckStatus = "RESOLVED"
	CheckStatusFailed   CheckStatus = "FAILED"
	CheckStatusPending  CheckStatus = "PENDING"
)

func NewCheckStatusFromString(s string) (CheckStatus, error) {
	switch s {
	case "RESOLVED":
		return CheckStatusResolved, nil
	case "FAILED":
		return CheckStatusFailed, nil
	case "PENDING":
		return CheckStatusPending, nil
	}
	var t CheckStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckStatus) Ptr() *CheckStatus {
	return &c
}

type MessageRouting struct {
	Method   MessageRoutingMethod     `json:"method,omitempty"`
	Channels []*MessageRoutingChannel `json:"channels,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageRouting(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageRouting) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageRoutingChannel struct {
	typeName       string
	String         string
	MessageRouting *MessageRouting
}

func NewMessageRoutingChannelFromString(value string) *MessageRoutingChannel {
	return &MessageRoutingChannel{typeName: "string", String: value}
}

func NewMessageRoutingChannelFromMessageRouting(value *MessageRouting) *MessageRoutingChannel {
	return &MessageRoutingChannel{typeName: "messageRouting", MessageRouting: value}
}

func (m *MessageRoutingChannel) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	valueMessageRouting := new(MessageRouting)
	if err := json.Unmarshal(data, &valueMessageRouting); err == nil {
		m.typeName = "messageRouting"
		m.MessageRouting = valueMessageRouting
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MessageRoutingChannel) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return json.Marshal(m.String)
	case "messageRouting":
		return json.Marshal(m.MessageRouting)
	}
}

type MessageRoutingChannelVisitor interface {
	VisitString(string) error
	VisitMessageRouting(*MessageRouting) error
}

func (m *MessageRoutingChannel) Accept(visitor MessageRoutingChannelVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return visitor.VisitString(m.String)
	case "messageRouting":
		return visitor.VisitMessageRouting(m.MessageRouting)
	}
}

type MessageRoutingMethod string

const (
	MessageRoutingMethodAll    MessageRoutingMethod = "all"
	MessageRoutingMethodSingle MessageRoutingMethod = "single"
)

func NewMessageRoutingMethodFromString(s string) (MessageRoutingMethod, error) {
	switch s {
	case "all":
		return MessageRoutingMethodAll, nil
	case "single":
		return MessageRoutingMethodSingle, nil
	}
	var t MessageRoutingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MessageRoutingMethod) Ptr() *MessageRoutingMethod {
	return &m
}

type Notification struct {
	CreatedAt int64           `json:"created_at"`
	Id        string          `json:"id"`
	Routing   *MessageRouting `json:"routing,omitempty"`

	_rawJSON json.RawMessage
}

func (n *Notification) UnmarshalJSON(data []byte) error {
	type unmarshaler Notification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Notification(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *Notification) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationChannelContent struct {
	Subject *string `json:"subject,omitempty"`
	Title   *string `json:"title,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotificationChannelContent) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationChannelContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationChannelContent(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationChannelContent) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationContent struct {
	typeName                     string
	String                       string
	NotificationContentHierarchy *NotificationContentHierarchy
}

func NewNotificationContentFromString(value string) *NotificationContent {
	return &NotificationContent{typeName: "string", String: value}
}

func NewNotificationContentFromNotificationContentHierarchy(value *NotificationContentHierarchy) *NotificationContent {
	return &NotificationContent{typeName: "notificationContentHierarchy", NotificationContentHierarchy: value}
}

func (n *NotificationContent) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueNotificationContentHierarchy := new(NotificationContentHierarchy)
	if err := json.Unmarshal(data, &valueNotificationContentHierarchy); err == nil {
		n.typeName = "notificationContentHierarchy"
		n.NotificationContentHierarchy = valueNotificationContentHierarchy
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NotificationContent) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "notificationContentHierarchy":
		return json.Marshal(n.NotificationContentHierarchy)
	}
}

type NotificationContentVisitor interface {
	VisitString(string) error
	VisitNotificationContentHierarchy(*NotificationContentHierarchy) error
}

func (n *NotificationContent) Accept(visitor NotificationContentVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "notificationContentHierarchy":
		return visitor.VisitNotificationContentHierarchy(n.NotificationContentHierarchy)
	}
}

type NotificationContentHierarchy struct {
	Parent   *string `json:"parent,omitempty"`
	Children *string `json:"children,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotificationContentHierarchy) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationContentHierarchy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationContentHierarchy(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationContentHierarchy) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Address struct {
	Formatted     string `json:"formatted"`
	StreetAddress string `json:"street_address"`
	Locality      string `json:"locality"`
	Region        string `json:"region"`
	PostalCode    string `json:"postal_code"`
	Country       string `json:"country"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AirshipProfile struct {
	Audience    *AirshipProfileAudience `json:"audience,omitempty"`
	DeviceTypes []DeviceType            `json:"device_types,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AirshipProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler AirshipProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AirshipProfile(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AirshipProfile) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AirshipProfileAudience struct {
	NamedUser string `json:"named_user"`

	_rawJSON json.RawMessage
}

func (a *AirshipProfileAudience) UnmarshalJSON(data []byte) error {
	type unmarshaler AirshipProfileAudience
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AirshipProfileAudience(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AirshipProfileAudience) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type DeviceType = interface{}

type Discord struct {
	typeName          string
	SendToChannel     *SendToChannel
	SendDirectMessage *SendDirectMessage
}

func NewDiscordFromSendToChannel(value *SendToChannel) *Discord {
	return &Discord{typeName: "sendToChannel", SendToChannel: value}
}

func NewDiscordFromSendDirectMessage(value *SendDirectMessage) *Discord {
	return &Discord{typeName: "sendDirectMessage", SendDirectMessage: value}
}

func (d *Discord) UnmarshalJSON(data []byte) error {
	valueSendToChannel := new(SendToChannel)
	if err := json.Unmarshal(data, &valueSendToChannel); err == nil {
		d.typeName = "sendToChannel"
		d.SendToChannel = valueSendToChannel
		return nil
	}
	valueSendDirectMessage := new(SendDirectMessage)
	if err := json.Unmarshal(data, &valueSendDirectMessage); err == nil {
		d.typeName = "sendDirectMessage"
		d.SendDirectMessage = valueSendDirectMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d Discord) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "sendToChannel":
		return json.Marshal(d.SendToChannel)
	case "sendDirectMessage":
		return json.Marshal(d.SendDirectMessage)
	}
}

type DiscordVisitor interface {
	VisitSendToChannel(*SendToChannel) error
	VisitSendDirectMessage(*SendDirectMessage) error
}

func (d *Discord) Accept(visitor DiscordVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "sendToChannel":
		return visitor.VisitSendToChannel(d.SendToChannel)
	case "sendDirectMessage":
		return visitor.VisitSendDirectMessage(d.SendDirectMessage)
	}
}

type Expo struct {
	typeName       string
	Token          *Token
	MultipleTokens *MultipleTokens
}

func NewExpoFromToken(value *Token) *Expo {
	return &Expo{typeName: "token", Token: value}
}

func NewExpoFromMultipleTokens(value *MultipleTokens) *Expo {
	return &Expo{typeName: "multipleTokens", MultipleTokens: value}
}

func (e *Expo) UnmarshalJSON(data []byte) error {
	valueToken := new(Token)
	if err := json.Unmarshal(data, &valueToken); err == nil {
		e.typeName = "token"
		e.Token = valueToken
		return nil
	}
	valueMultipleTokens := new(MultipleTokens)
	if err := json.Unmarshal(data, &valueMultipleTokens); err == nil {
		e.typeName = "multipleTokens"
		e.MultipleTokens = valueMultipleTokens
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e Expo) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "token":
		return json.Marshal(e.Token)
	case "multipleTokens":
		return json.Marshal(e.MultipleTokens)
	}
}

type ExpoVisitor interface {
	VisitToken(*Token) error
	VisitMultipleTokens(*MultipleTokens) error
}

func (e *Expo) Accept(visitor ExpoVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "token":
		return visitor.VisitToken(e.Token)
	case "multipleTokens":
		return visitor.VisitMultipleTokens(e.MultipleTokens)
	}
}

type GetListSubscriptionsList struct {
	Id string `json:"id"`
	// List name
	Name string `json:"name"`
	// The date/time of when the list was created. Represented as a string in ISO format.
	Created string `json:"created"`
	// The date/time of when the list was updated. Represented as a string in ISO format.
	Updated     string                `json:"updated"`
	Preferences *RecipientPreferences `json:"preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetListSubscriptionsList) UnmarshalJSON(data []byte) error {
	type unmarshaler GetListSubscriptionsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetListSubscriptionsList(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetListSubscriptionsList) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Intercom struct {
	From string             `json:"from"`
	To   *IntercomRecipient `json:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Intercom) UnmarshalJSON(data []byte) error {
	type unmarshaler Intercom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Intercom(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Intercom) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntercomRecipient struct {
	Id string `json:"id"`

	_rawJSON json.RawMessage
}

func (i *IntercomRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler IntercomRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntercomRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntercomRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MsTeams struct {
	typeName                    string
	SendToMsTeamsUserId         *SendToMsTeamsUserId
	SendToMsTeamsEmail          *SendToMsTeamsEmail
	SendToMsTeamsChannelId      *SendToMsTeamsChannelId
	SendToMsTeamsConversationId *SendToMsTeamsConversationId
	SendToMsTeamsChannelName    *SendToMsTeamsChannelName
}

func NewMsTeamsFromSendToMsTeamsUserId(value *SendToMsTeamsUserId) *MsTeams {
	return &MsTeams{typeName: "sendToMsTeamsUserId", SendToMsTeamsUserId: value}
}

func NewMsTeamsFromSendToMsTeamsEmail(value *SendToMsTeamsEmail) *MsTeams {
	return &MsTeams{typeName: "sendToMsTeamsEmail", SendToMsTeamsEmail: value}
}

func NewMsTeamsFromSendToMsTeamsChannelId(value *SendToMsTeamsChannelId) *MsTeams {
	return &MsTeams{typeName: "sendToMsTeamsChannelId", SendToMsTeamsChannelId: value}
}

func NewMsTeamsFromSendToMsTeamsConversationId(value *SendToMsTeamsConversationId) *MsTeams {
	return &MsTeams{typeName: "sendToMsTeamsConversationId", SendToMsTeamsConversationId: value}
}

func NewMsTeamsFromSendToMsTeamsChannelName(value *SendToMsTeamsChannelName) *MsTeams {
	return &MsTeams{typeName: "sendToMsTeamsChannelName", SendToMsTeamsChannelName: value}
}

func (m *MsTeams) UnmarshalJSON(data []byte) error {
	valueSendToMsTeamsUserId := new(SendToMsTeamsUserId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsUserId); err == nil {
		m.typeName = "sendToMsTeamsUserId"
		m.SendToMsTeamsUserId = valueSendToMsTeamsUserId
		return nil
	}
	valueSendToMsTeamsEmail := new(SendToMsTeamsEmail)
	if err := json.Unmarshal(data, &valueSendToMsTeamsEmail); err == nil {
		m.typeName = "sendToMsTeamsEmail"
		m.SendToMsTeamsEmail = valueSendToMsTeamsEmail
		return nil
	}
	valueSendToMsTeamsChannelId := new(SendToMsTeamsChannelId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsChannelId); err == nil {
		m.typeName = "sendToMsTeamsChannelId"
		m.SendToMsTeamsChannelId = valueSendToMsTeamsChannelId
		return nil
	}
	valueSendToMsTeamsConversationId := new(SendToMsTeamsConversationId)
	if err := json.Unmarshal(data, &valueSendToMsTeamsConversationId); err == nil {
		m.typeName = "sendToMsTeamsConversationId"
		m.SendToMsTeamsConversationId = valueSendToMsTeamsConversationId
		return nil
	}
	valueSendToMsTeamsChannelName := new(SendToMsTeamsChannelName)
	if err := json.Unmarshal(data, &valueSendToMsTeamsChannelName); err == nil {
		m.typeName = "sendToMsTeamsChannelName"
		m.SendToMsTeamsChannelName = valueSendToMsTeamsChannelName
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MsTeams) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "sendToMsTeamsUserId":
		return json.Marshal(m.SendToMsTeamsUserId)
	case "sendToMsTeamsEmail":
		return json.Marshal(m.SendToMsTeamsEmail)
	case "sendToMsTeamsChannelId":
		return json.Marshal(m.SendToMsTeamsChannelId)
	case "sendToMsTeamsConversationId":
		return json.Marshal(m.SendToMsTeamsConversationId)
	case "sendToMsTeamsChannelName":
		return json.Marshal(m.SendToMsTeamsChannelName)
	}
}

type MsTeamsVisitor interface {
	VisitSendToMsTeamsUserId(*SendToMsTeamsUserId) error
	VisitSendToMsTeamsEmail(*SendToMsTeamsEmail) error
	VisitSendToMsTeamsChannelId(*SendToMsTeamsChannelId) error
	VisitSendToMsTeamsConversationId(*SendToMsTeamsConversationId) error
	VisitSendToMsTeamsChannelName(*SendToMsTeamsChannelName) error
}

func (m *MsTeams) Accept(visitor MsTeamsVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "sendToMsTeamsUserId":
		return visitor.VisitSendToMsTeamsUserId(m.SendToMsTeamsUserId)
	case "sendToMsTeamsEmail":
		return visitor.VisitSendToMsTeamsEmail(m.SendToMsTeamsEmail)
	case "sendToMsTeamsChannelId":
		return visitor.VisitSendToMsTeamsChannelId(m.SendToMsTeamsChannelId)
	case "sendToMsTeamsConversationId":
		return visitor.VisitSendToMsTeamsConversationId(m.SendToMsTeamsConversationId)
	case "sendToMsTeamsChannelName":
		return visitor.VisitSendToMsTeamsChannelName(m.SendToMsTeamsChannelName)
	}
}

type MsTeamsBaseProperties struct {
	TenantId   string `json:"tenant_id"`
	ServiceUrl string `json:"service_url"`

	_rawJSON json.RawMessage
}

func (m *MsTeamsBaseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler MsTeamsBaseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MsTeamsBaseProperties(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MsTeamsBaseProperties) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleTokens struct {
	Tokens []*Token `json:"tokens,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MultipleTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleTokens(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipleTokens) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ProfileGetParameters struct {
	RecipientId string `json:"recipientId"`

	_rawJSON json.RawMessage
}

func (p *ProfileGetParameters) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileGetParameters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileGetParameters(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileGetParameters) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SendDirectMessage struct {
	UserId string `json:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendDirectMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SendDirectMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendDirectMessage(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendDirectMessage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToChannel struct {
	ChannelId string `json:"channel_id"`

	_rawJSON json.RawMessage
}

func (s *SendToChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToChannel(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToChannel) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsChannelId struct {
	TenantId   string `json:"tenant_id"`
	ServiceUrl string `json:"service_url"`
	ChannelId  string `json:"channel_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsChannelId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsChannelId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsChannelId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsChannelId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsChannelName struct {
	TenantId    string `json:"tenant_id"`
	ServiceUrl  string `json:"service_url"`
	ChannelName string `json:"channel_name"`
	TeamId      string `json:"team_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsChannelName) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsChannelName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsChannelName(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsChannelName) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsConversationId struct {
	TenantId       string `json:"tenant_id"`
	ServiceUrl     string `json:"service_url"`
	ConversationId string `json:"conversation_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsConversationId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsConversationId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsConversationId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsConversationId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsEmail struct {
	TenantId   string `json:"tenant_id"`
	ServiceUrl string `json:"service_url"`
	Email      string `json:"email"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsEmail(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsEmail) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToMsTeamsUserId struct {
	TenantId   string `json:"tenant_id"`
	ServiceUrl string `json:"service_url"`
	UserId     string `json:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendToMsTeamsUserId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToMsTeamsUserId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToMsTeamsUserId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToMsTeamsUserId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackChannel struct {
	AccessToken string `json:"access_token"`
	Channel     string `json:"channel"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackChannel(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackChannel) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackEmail struct {
	AccessToken string `json:"access_token"`
	Email       string `json:"email"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackEmail(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackEmail) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SendToSlackUserId struct {
	AccessToken string `json:"access_token"`
	UserId      string `json:"user_id"`

	_rawJSON json.RawMessage
}

func (s *SendToSlackUserId) UnmarshalJSON(data []byte) error {
	type unmarshaler SendToSlackUserId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendToSlackUserId(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SendToSlackUserId) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Slack struct {
	typeName           string
	SendToSlackChannel *SendToSlackChannel
	SendToSlackEmail   *SendToSlackEmail
	SendToSlackUserId  *SendToSlackUserId
}

func NewSlackFromSendToSlackChannel(value *SendToSlackChannel) *Slack {
	return &Slack{typeName: "sendToSlackChannel", SendToSlackChannel: value}
}

func NewSlackFromSendToSlackEmail(value *SendToSlackEmail) *Slack {
	return &Slack{typeName: "sendToSlackEmail", SendToSlackEmail: value}
}

func NewSlackFromSendToSlackUserId(value *SendToSlackUserId) *Slack {
	return &Slack{typeName: "sendToSlackUserId", SendToSlackUserId: value}
}

func (s *Slack) UnmarshalJSON(data []byte) error {
	valueSendToSlackChannel := new(SendToSlackChannel)
	if err := json.Unmarshal(data, &valueSendToSlackChannel); err == nil {
		s.typeName = "sendToSlackChannel"
		s.SendToSlackChannel = valueSendToSlackChannel
		return nil
	}
	valueSendToSlackEmail := new(SendToSlackEmail)
	if err := json.Unmarshal(data, &valueSendToSlackEmail); err == nil {
		s.typeName = "sendToSlackEmail"
		s.SendToSlackEmail = valueSendToSlackEmail
		return nil
	}
	valueSendToSlackUserId := new(SendToSlackUserId)
	if err := json.Unmarshal(data, &valueSendToSlackUserId); err == nil {
		s.typeName = "sendToSlackUserId"
		s.SendToSlackUserId = valueSendToSlackUserId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s Slack) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "sendToSlackChannel":
		return json.Marshal(s.SendToSlackChannel)
	case "sendToSlackEmail":
		return json.Marshal(s.SendToSlackEmail)
	case "sendToSlackUserId":
		return json.Marshal(s.SendToSlackUserId)
	}
}

type SlackVisitor interface {
	VisitSendToSlackChannel(*SendToSlackChannel) error
	VisitSendToSlackEmail(*SendToSlackEmail) error
	VisitSendToSlackUserId(*SendToSlackUserId) error
}

func (s *Slack) Accept(visitor SlackVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "sendToSlackChannel":
		return visitor.VisitSendToSlackChannel(s.SendToSlackChannel)
	case "sendToSlackEmail":
		return visitor.VisitSendToSlackEmail(s.SendToSlackEmail)
	case "sendToSlackUserId":
		return visitor.VisitSendToSlackUserId(s.SendToSlackUserId)
	}
}

type SlackBaseProperties struct {
	AccessToken string `json:"access_token"`

	_rawJSON json.RawMessage
}

func (s *SlackBaseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SlackBaseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlackBaseProperties(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackBaseProperties) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnoozeRule struct {
	Type  SnoozeRuleType `json:"type,omitempty"`
	Start string         `json:"start"`
	Until string         `json:"until"`

	_rawJSON json.RawMessage
}

func (s *SnoozeRule) UnmarshalJSON(data []byte) error {
	type unmarshaler SnoozeRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnoozeRule(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnoozeRule) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnoozeRuleType string

const (
	SnoozeRuleTypeSnooze SnoozeRuleType = "snooze"
)

func NewSnoozeRuleTypeFromString(s string) (SnoozeRuleType, error) {
	switch s {
	case "snooze":
		return SnoozeRuleTypeSnooze, nil
	}
	var t SnoozeRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SnoozeRuleType) Ptr() *SnoozeRuleType {
	return &s
}

type SubscribeToListsRequestListObject struct {
	ListId      string                `json:"listId"`
	Preferences *RecipientPreferences `json:"preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SubscribeToListsRequestListObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscribeToListsRequestListObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscribeToListsRequestListObject(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscribeToListsRequestListObject) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Token struct {
	Token string `json:"token"`

	_rawJSON json.RawMessage
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type unmarshaler Token
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Token(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UserProfile struct {
	Address             *Address `json:"address,omitempty"`
	Birthdate           string   `json:"birthdate"`
	Email               string   `json:"email"`
	EmailVerified       bool     `json:"email_verified"`
	FamilyName          string   `json:"family_name"`
	Gender              string   `json:"gender"`
	GivenName           string   `json:"given_name"`
	Locale              string   `json:"locale"`
	MiddleName          string   `json:"middle_name"`
	Name                string   `json:"name"`
	Nickname            string   `json:"nickname"`
	PhoneNumber         string   `json:"phone_number"`
	PhoneNumberVerified bool     `json:"phone_number_verified"`
	Picture             string   `json:"picture"`
	PreferredName       string   `json:"preferred_name"`
	Profile             string   `json:"profile"`
	Sub                 string   `json:"sub"`
	UpdatedAt           string   `json:"updated_at"`
	Website             string   `json:"website"`
	Zoneinfo            string   `json:"zoneinfo"`
	// A free form object. Due to a limitation of the API Explorer, you can only enter string key/values below, but this API accepts more complex object structures.
	Custom        interface{}     `json:"custom,omitempty"`
	Airship       *AirshipProfile `json:"airship,omitempty"`
	Apn           string          `json:"apn"`
	TargetArn     string          `json:"target_arn"`
	Discord       *Discord        `json:"discord,omitempty"`
	Expo          *Expo           `json:"expo,omitempty"`
	FacebookPsid  string          `json:"facebookPSID"`
	FirebaseToken string          `json:"firebaseToken"`
	Intercom      *Intercom       `json:"intercom,omitempty"`
	Slack         *Slack          `json:"slack,omitempty"`
	MsTeams       *MsTeams        `json:"ms_teams,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfile(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfile) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type Attachment = map[string]interface{}

type AudienceFilter struct {
	// Send to users only if they are member of the account
	Value    string `json:"value"`
	operator string
	path     string

	_rawJSON json.RawMessage
}

func (a *AudienceFilter) Operator() string {
	return a.operator
}

func (a *AudienceFilter) Path() string {
	return a.path
}

func (a *AudienceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceFilter(value)
	a.operator = "MEMBER_OF"
	a.path = "account_id"
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceFilter) MarshalJSON() ([]byte, error) {
	type embed AudienceFilter
	var marshaler = struct {
		embed
		Operator string `json:"operator"`
		Path     string `json:"path"`
	}{
		embed:    embed(*a),
		Operator: "MEMBER_OF",
		Path:     "account_id",
	}
	return json.Marshal(marshaler)
}

func (a *AudienceFilter) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AudienceRecipient struct {
	// A unique identifier associated with an Audience. A message will be sent to each user in the audience.
	AudienceId string            `json:"audience_id"`
	Data       *MessageData      `json:"data,omitempty"`
	Filters    []*AudienceFilter `json:"filters,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AudienceRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceRecipient(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata *MessageMetadata `json:"metadata,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Defines the time to wait before delivering the message.
	Delay *Delay `json:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseMessage(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseMessage) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseSocialPresence struct {
	Url string `json:"url"`

	_rawJSON json.RawMessage
}

func (b *BaseSocialPresence) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseSocialPresence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseSocialPresence(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseSocialPresence) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsEmail struct {
	TemplateOverride *BrandTemplateOverride `json:"templateOverride,omitempty"`
	Head             *EmailHead             `json:"head,omitempty"`
	Footer           *EmailFooter           `json:"footer,omitempty"`
	Header           *EmailHeader           `json:"header,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsEmail(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsEmail) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsInApp struct {
	BorderRadius       *string           `json:"borderRadius,omitempty"`
	DisableMessageIcon *bool             `json:"disableMessageIcon,omitempty"`
	FontFamily         *string           `json:"fontFamily,omitempty"`
	Placement          *InAppPlacement   `json:"placement,omitempty"`
	WidgetBackground   *WidgetBackground `json:"widgetBackground,omitempty"`
	Colors             *BrandColors      `json:"colors,omitempty"`
	Icons              *Icons            `json:"icons,omitempty"`
	Preferences        *Preferences      `json:"preferences,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsInApp) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsInApp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsInApp(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsInApp) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandSettingsSocialPresence struct {
	InheritDefault *bool               `json:"inheritDefault,omitempty"`
	Facebook       *BaseSocialPresence `json:"facebook,omitempty"`
	Instagram      *BaseSocialPresence `json:"instagram,omitempty"`
	Linkedin       *BaseSocialPresence `json:"linkedin,omitempty"`
	Medium         *BaseSocialPresence `json:"medium,omitempty"`
	Twitter        *BaseSocialPresence `json:"twitter,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandSettingsSocialPresence) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandSettingsSocialPresence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandSettingsSocialPresence(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandSettingsSocialPresence) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandTemplate struct {
	BackgroundColor       *string `json:"backgroundColor,omitempty"`
	BlocksBackgroundColor *string `json:"blocksBackgroundColor,omitempty"`
	Enabled               bool    `json:"enabled"`
	Footer                *string `json:"footer,omitempty"`
	Head                  *string `json:"head,omitempty"`
	Header                *string `json:"header,omitempty"`
	Width                 *string `json:"width,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandTemplate) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandTemplate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandTemplate(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandTemplate) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrandTemplateOverride struct {
	BackgroundColor       *string        `json:"backgroundColor,omitempty"`
	BlocksBackgroundColor *string        `json:"blocksBackgroundColor,omitempty"`
	Enabled               bool           `json:"enabled"`
	Footer                *string        `json:"footer,omitempty"`
	Head                  *string        `json:"head,omitempty"`
	Header                *string        `json:"header,omitempty"`
	Width                 *string        `json:"width,omitempty"`
	Mjml                  *BrandTemplate `json:"mjml,omitempty"`
	FooterBackgroundColor *string        `json:"footerBackgroundColor,omitempty"`
	FooterFullWidth       *bool          `json:"footerFullWidth,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BrandTemplateOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler BrandTemplateOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrandTemplateOverride(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrandTemplateOverride) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Channel struct {
	// Id of the brand that should be used for rendering the message.
	// If not specified, the brand configured as default brand will be used.
	BrandId *string `json:"brand_id,omitempty"`
	// A list of providers enabled for this channel. Courier will select
	// one provider to send through unless routing_method is set to all.
	Providers []string `json:"providers,omitempty"`
	// The method for selecting the providers to send the message with.
	// Single will send to one of the available providers for this channel,
	// all will send the message through all channels. Defaults to `single`.
	RoutingMethod *RoutingMethod `json:"routing_method,omitempty"`
	// A JavaScript conditional expression to determine if the message should
	// be sent through the channel. Has access to the data and profile object.
	// For example, `data.name === profile.name`
	If       *string   `json:"if,omitempty"`
	Timeouts *Timeouts `json:"timeouts,omitempty"`
	// Channel specific overrides.
	Override *Override        `json:"override,omitempty"`
	Metadata *ChannelMetadata `json:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Channel) UnmarshalJSON(data []byte) error {
	type unmarshaler Channel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Channel(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Channel) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChannelMetadata struct {
	Utm *Utm `json:"utm,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChannelMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ChannelMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChannelMetadata(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChannelMetadata) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChannelSource string

const (
	ChannelSourceSubscription ChannelSource = "subscription"
	ChannelSourceList         ChannelSource = "list"
	ChannelSourceRecipient    ChannelSource = "recipient"
)

func NewChannelSourceFromString(s string) (ChannelSource, error) {
	switch s {
	case "subscription":
		return ChannelSourceSubscription, nil
	case "list":
		return ChannelSourceList, nil
	case "recipient":
		return ChannelSourceRecipient, nil
	}
	var t ChannelSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChannelSource) Ptr() *ChannelSource {
	return &c
}

type Content struct {
	typeName              string
	ElementalContent      *ElementalContent
	ElementalContentSugar *ElementalContentSugar
}

func NewContentFromElementalContent(value *ElementalContent) *Content {
	return &Content{typeName: "elementalContent", ElementalContent: value}
}

func NewContentFromElementalContentSugar(value *ElementalContentSugar) *Content {
	return &Content{typeName: "elementalContentSugar", ElementalContentSugar: value}
}

func (c *Content) UnmarshalJSON(data []byte) error {
	valueElementalContent := new(ElementalContent)
	if err := json.Unmarshal(data, &valueElementalContent); err == nil {
		c.typeName = "elementalContent"
		c.ElementalContent = valueElementalContent
		return nil
	}
	valueElementalContentSugar := new(ElementalContentSugar)
	if err := json.Unmarshal(data, &valueElementalContentSugar); err == nil {
		c.typeName = "elementalContentSugar"
		c.ElementalContentSugar = valueElementalContentSugar
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c Content) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "elementalContent":
		return json.Marshal(c.ElementalContent)
	case "elementalContentSugar":
		return json.Marshal(c.ElementalContentSugar)
	}
}

type ContentVisitor interface {
	VisitElementalContent(*ElementalContent) error
	VisitElementalContentSugar(*ElementalContentSugar) error
}

func (c *Content) Accept(visitor ContentVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "elementalContent":
		return visitor.VisitElementalContent(c.ElementalContent)
	case "elementalContentSugar":
		return visitor.VisitElementalContentSugar(c.ElementalContentSugar)
	}
}

// The message property has the following primary top-level properties. They define the destination and content of the message.
// Additional advanced configuration fields [are defined below](https://www.courier.com/docs/reference/send/message/#other-message-properties).
type ContentMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata *MessageMetadata `json:"metadata,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Defines the time to wait before delivering the message.
	Delay *Delay `json:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty"`
	// Describes the content of the message in a way that will work for email, push,
	// chat, or any channel. Either this or template must be specified.
	Content *Content `json:"content,omitempty"`
	// The recipient or a list of recipients of the message
	To *MessageRecipient `json:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ContentMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ContentMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContentMessage(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContentMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Criteria string

const (
	CriteriaNoEscalation Criteria = "no-escalation"
	CriteriaDelivered    Criteria = "delivered"
	CriteriaViewed       Criteria = "viewed"
	CriteriaEngaged      Criteria = "engaged"
)

func NewCriteriaFromString(s string) (Criteria, error) {
	switch s {
	case "no-escalation":
		return CriteriaNoEscalation, nil
	case "delivered":
		return CriteriaDelivered, nil
	case "viewed":
		return CriteriaViewed, nil
	case "engaged":
		return CriteriaEngaged, nil
	}
	var t Criteria
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Criteria) Ptr() *Criteria {
	return &c
}

type Delay struct {
	// The duration of the delay in milliseconds.
	Duration int `json:"duration"`

	_rawJSON json.RawMessage
}

func (d *Delay) UnmarshalJSON(data []byte) error {
	type unmarshaler Delay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Delay(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Delay) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Allows the user to execute an action. Can be a button or a link.
type ElementalActionNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The text content of the action shown to the user.
	Content string `json:"content"`
	// The target URL of the action.
	Href string `json:"href"`
	// A unique id used to identify the action when it is executed.
	ActionId *string `json:"action_id,omitempty"`
	// The alignment of the action button. Defaults to "center".
	Align *IAlignment `json:"align,omitempty"`
	// The background color of the action button.
	BackgroundColor *string `json:"background_color,omitempty"`
	// Defaults to `button`.
	Style *IActionButtonStyle `json:"style,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales Locales `json:"locales,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalActionNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalActionNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalActionNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalActionNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalBaseNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalBaseNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalBaseNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalBaseNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalBaseNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The channel element allows a notification to be customized based on which channel it is sent through.
// For example, you may want to display a detailed message when the notification is sent through email,
// and a more concise message in a push notification. Channel elements are only valid as top-level
// elements; you cannot nest channel elements. If there is a channel element specified at the top-level
// of the document, all sibling elements must be channel elements.
// Note: As an alternative, most elements support a `channel` property. Which allows you to selectively
// display an individual element on a per channel basis. See the
// [control flow docs](https://www.courier.com/docs/platform/content/elemental/control-flow/) for more details.
type ElementalChannelNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The channel the contents of this element should be applied to. Can be `email`,
	// `push`, `direct_message`, `sms` or a provider such as slack
	Channel string `json:"channel"`
	// An array of elements to apply to the channel. If `raw` has not been
	// specified, `elements` is `required`.
	Elements []*ElementalNode `json:"elements,omitempty"`
	// Raw data to apply to the channel. If `elements` has not been
	// specified, `raw` is `required`.
	Raw map[string]interface{} `json:"raw,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalChannelNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalChannelNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalChannelNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalChannelNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalContent struct {
	// For example, "2022-01-01"
	Version  string           `json:"version"`
	Brand    interface{}      `json:"brand,omitempty"`
	Elements []*ElementalNode `json:"elements,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalContent(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalContent) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Syntatic Sugar to provide a fast shorthand for Courier Elemental Blocks.
type ElementalContentSugar struct {
	// The title to be displayed by supported channels i.e. push, email (as subject)
	Title string `json:"title"`
	// The text content displayed in the notification.
	Body string `json:"body"`

	_rawJSON json.RawMessage
}

func (e *ElementalContentSugar) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalContentSugar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalContentSugar(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalContentSugar) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Renders a dividing line between elements.
type ElementalDividerNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The CSS color to render the line with. For example, `#fff`
	Color *string `json:"color,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalDividerNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalDividerNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalDividerNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalDividerNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Allows you to group elements together. This can be useful when used in combination with "if" or "loop". See [control flow docs](https://www.courier.com/docs/platform/content/elemental/control-flow/) for more details.
type ElementalGroupNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// Sub elements to render.
	Elements []*ElementalNode `json:"elements,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalGroupNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalGroupNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalGroupNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalGroupNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Used to embed an image into the notification.
type ElementalImageNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The source of the image.
	Src string `json:"src"`
	// A URL to link to when the image is clicked.
	Href *string `json:"href,omitempty"`
	// The alignment of the image.
	Align *IAlignment `json:"align,omitempty"`
	// Alternate text for the image.
	AltText *string `json:"altText,omitempty"`
	// CSS width properties to apply to the image. For example, 50px
	Width *string `json:"width,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalImageNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalImageNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalImageNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalImageNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The meta element contains information describing the notification that may
// be used by a particular channel or provider. One important field is the title
// field which will be used as the title for channels that support it.
type ElementalMetaNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The title to be displayed by supported channels. For example, the email subject.
	Title *string `json:"title,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalMetaNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalMetaNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalMetaNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalMetaNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElementalNode struct {
	Type    string
	Text    *ElementalTextNode
	Meta    *ElementalMetaNode
	Channel *ElementalChannelNode
	Image   *ElementalImageNode
	Action  *ElementalActionNode
	Divider *ElementalDividerNode
	Group   *ElementalGroupNode
	Quote   *ElementalQuoteNode
}

func NewElementalNodeFromText(value *ElementalTextNode) *ElementalNode {
	return &ElementalNode{Type: "text", Text: value}
}

func NewElementalNodeFromMeta(value *ElementalMetaNode) *ElementalNode {
	return &ElementalNode{Type: "meta", Meta: value}
}

func NewElementalNodeFromChannel(value *ElementalChannelNode) *ElementalNode {
	return &ElementalNode{Type: "channel", Channel: value}
}

func NewElementalNodeFromImage(value *ElementalImageNode) *ElementalNode {
	return &ElementalNode{Type: "image", Image: value}
}

func NewElementalNodeFromAction(value *ElementalActionNode) *ElementalNode {
	return &ElementalNode{Type: "action", Action: value}
}

func NewElementalNodeFromDivider(value *ElementalDividerNode) *ElementalNode {
	return &ElementalNode{Type: "divider", Divider: value}
}

func NewElementalNodeFromGroup(value *ElementalGroupNode) *ElementalNode {
	return &ElementalNode{Type: "group", Group: value}
}

func NewElementalNodeFromQuote(value *ElementalQuoteNode) *ElementalNode {
	return &ElementalNode{Type: "quote", Quote: value}
}

func (e *ElementalNode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "text":
		value := new(ElementalTextNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Text = value
	case "meta":
		value := new(ElementalMetaNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Meta = value
	case "channel":
		value := new(ElementalChannelNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Channel = value
	case "image":
		value := new(ElementalImageNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Image = value
	case "action":
		value := new(ElementalActionNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Action = value
	case "divider":
		value := new(ElementalDividerNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Divider = value
	case "group":
		value := new(ElementalGroupNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Group = value
	case "quote":
		value := new(ElementalQuoteNode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Quote = value
	}
	return nil
}

func (e ElementalNode) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "text":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalTextNode
		}{
			Type:              e.Type,
			ElementalTextNode: e.Text,
		}
		return json.Marshal(marshaler)
	case "meta":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalMetaNode
		}{
			Type:              e.Type,
			ElementalMetaNode: e.Meta,
		}
		return json.Marshal(marshaler)
	case "channel":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalChannelNode
		}{
			Type:                 e.Type,
			ElementalChannelNode: e.Channel,
		}
		return json.Marshal(marshaler)
	case "image":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalImageNode
		}{
			Type:               e.Type,
			ElementalImageNode: e.Image,
		}
		return json.Marshal(marshaler)
	case "action":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalActionNode
		}{
			Type:                e.Type,
			ElementalActionNode: e.Action,
		}
		return json.Marshal(marshaler)
	case "divider":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalDividerNode
		}{
			Type:                 e.Type,
			ElementalDividerNode: e.Divider,
		}
		return json.Marshal(marshaler)
	case "group":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalGroupNode
		}{
			Type:               e.Type,
			ElementalGroupNode: e.Group,
		}
		return json.Marshal(marshaler)
	case "quote":
		var marshaler = struct {
			Type string `json:"type"`
			*ElementalQuoteNode
		}{
			Type:               e.Type,
			ElementalQuoteNode: e.Quote,
		}
		return json.Marshal(marshaler)
	}
}

type ElementalNodeVisitor interface {
	VisitText(*ElementalTextNode) error
	VisitMeta(*ElementalMetaNode) error
	VisitChannel(*ElementalChannelNode) error
	VisitImage(*ElementalImageNode) error
	VisitAction(*ElementalActionNode) error
	VisitDivider(*ElementalDividerNode) error
	VisitGroup(*ElementalGroupNode) error
	VisitQuote(*ElementalQuoteNode) error
}

func (e *ElementalNode) Accept(visitor ElementalNodeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "text":
		return visitor.VisitText(e.Text)
	case "meta":
		return visitor.VisitMeta(e.Meta)
	case "channel":
		return visitor.VisitChannel(e.Channel)
	case "image":
		return visitor.VisitImage(e.Image)
	case "action":
		return visitor.VisitAction(e.Action)
	case "divider":
		return visitor.VisitDivider(e.Divider)
	case "group":
		return visitor.VisitGroup(e.Group)
	case "quote":
		return visitor.VisitQuote(e.Quote)
	}
}

// Renders a quote block.
type ElementalQuoteNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The text value of the quote.
	Content string `json:"content"`
	// Alignment of the quote.
	Align *IAlignment `json:"align,omitempty"`
	// CSS border color property. For example, `#fff`
	BorderColor *string   `json:"borderColor,omitempty"`
	TextStyle   TextStyle `json:"text_style,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales Locales `json:"locales,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalQuoteNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalQuoteNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalQuoteNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalQuoteNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents a body of text to be rendered inside of the notification.
type ElementalTextNode struct {
	Channels []string `json:"channels,omitempty"`
	Ref      *string  `json:"ref,omitempty"`
	If       *string  `json:"if,omitempty"`
	Loop     *string  `json:"loop,omitempty"`
	// The text content displayed in the notification. Either this
	// field must be specified, or the elements field
	Content string `json:"content"`
	// Text alignment.
	Align TextAlign `json:"align,omitempty"`
	// Allows the text to be rendered as a heading level.
	TextStyle *TextStyle `json:"text_style,omitempty"`
	// Specifies the color of text. Can be any valid css color value
	Color *string `json:"color,omitempty"`
	// Apply bold to the text
	Bold *string `json:"bold,omitempty"`
	// Apply italics to the text
	Italic *string `json:"italic,omitempty"`
	// Apply a strike through the text
	Strikethrough *string `json:"strikethrough,omitempty"`
	// Apply an underline to the text
	Underline *string `json:"underline,omitempty"`
	// Region specific content. See [locales docs](https://www.courier.com/docs/platform/content/elemental/locales/) for more details.
	Locales *Locales `json:"locales,omitempty"`
	Format  *string  `json:"format,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ElementalTextNode) UnmarshalJSON(data []byte) error {
	type unmarshaler ElementalTextNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElementalTextNode(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElementalTextNode) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailFooter struct {
	Content        interface{} `json:"content,omitempty"`
	InheritDefault *bool       `json:"inheritDefault,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailFooter) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailFooter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailFooter(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailFooter) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailHead struct {
	InheritDefault bool    `json:"inheritDefault"`
	Content        *string `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailHead) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailHead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailHead(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailHead) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailHeader struct {
	InheritDefault *bool   `json:"inheritDefault,omitempty"`
	BarColor       *string `json:"barColor,omitempty"`
	Logo           *Logo   `json:"logo,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailHeader(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailHeader) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExpiresInType struct {
	typeName string
	String   string
	Integer  int
}

func NewExpiresInTypeFromString(value string) *ExpiresInType {
	return &ExpiresInType{typeName: "string", String: value}
}

func NewExpiresInTypeFromInteger(value int) *ExpiresInType {
	return &ExpiresInType{typeName: "integer", Integer: value}
}

func (e *ExpiresInType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpiresInType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "integer":
		return json.Marshal(e.Integer)
	}
}

type ExpiresInTypeVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (e *ExpiresInType) Accept(visitor ExpiresInTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	}
}

type Expiry struct {
	// An epoch timestamp or ISO8601 timestamp with timezone `(YYYY-MM-DDThh:mm:ss.sTZD)` that describes the time in which a message expires.
	ExpiresAt *string `json:"expires_at,omitempty"`
	// A duration in the form of milliseconds or an ISO8601 Duration format (i.e. P1DT4H).
	ExpiresIn *ExpiresInType `json:"expires_in,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Expiry) UnmarshalJSON(data []byte) error {
	type unmarshaler Expiry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Expiry(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Expiry) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type IActionButtonStyle string

const (
	IActionButtonStyleButton IActionButtonStyle = "button"
	IActionButtonStyleLink   IActionButtonStyle = "link"
)

func NewIActionButtonStyleFromString(s string) (IActionButtonStyle, error) {
	switch s {
	case "button":
		return IActionButtonStyleButton, nil
	case "link":
		return IActionButtonStyleLink, nil
	}
	var t IActionButtonStyle
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IActionButtonStyle) Ptr() *IActionButtonStyle {
	return &i
}

type IAlignment string

const (
	IAlignmentCenter IAlignment = "center"
	IAlignmentLeft   IAlignment = "left"
	IAlignmentRight  IAlignment = "right"
	IAlignmentFull   IAlignment = "full"
)

func NewIAlignmentFromString(s string) (IAlignment, error) {
	switch s {
	case "center":
		return IAlignmentCenter, nil
	case "left":
		return IAlignmentLeft, nil
	case "right":
		return IAlignmentRight, nil
	case "full":
		return IAlignmentFull, nil
	}
	var t IAlignment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IAlignment) Ptr() *IAlignment {
	return &i
}

type IPreferences = map[string]*Preference

type IProfilePreferences struct {
	Categories    *IPreferences `json:"categories,omitempty"`
	Notifications IPreferences  `json:"notifications,omitempty"`
	TemplateId    *string       `json:"templateId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IProfilePreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler IProfilePreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IProfilePreferences(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IProfilePreferences) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Icons struct {
	Bell    *string `json:"bell,omitempty"`
	Message *string `json:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Icons) UnmarshalJSON(data []byte) error {
	type unmarshaler Icons
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Icons(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Icons) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InAppPlacement string

const (
	InAppPlacementTop    InAppPlacement = "top"
	InAppPlacementBottom InAppPlacement = "bottom"
	InAppPlacementLeft   InAppPlacement = "left"
	InAppPlacementRight  InAppPlacement = "right"
)

func NewInAppPlacementFromString(s string) (InAppPlacement, error) {
	switch s {
	case "top":
		return InAppPlacementTop, nil
	case "bottom":
		return InAppPlacementBottom, nil
	case "left":
		return InAppPlacementLeft, nil
	case "right":
		return InAppPlacementRight, nil
	}
	var t InAppPlacement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InAppPlacement) Ptr() *InAppPlacement {
	return &i
}

type InvalidListPatternRecipient struct {
	UserId string `json:"user_id"`
	ListId string `json:"list_id"`

	_rawJSON json.RawMessage
}

func (i *InvalidListPatternRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidListPatternRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidListPatternRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidListPatternRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvalidListRecipient struct {
	UserId      string `json:"user_id"`
	ListPattern string `json:"list_pattern"`

	_rawJSON json.RawMessage
}

func (i *InvalidListRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidListRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidListRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidListRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvalidUserRecipient struct {
	ListId      string `json:"list_id"`
	ListPattern string `json:"list_pattern"`

	_rawJSON json.RawMessage
}

func (i *InvalidUserRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvalidUserRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvalidUserRecipient(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvalidUserRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type ListFilter struct {
	// Send to users only if they are member of the account
	Value    string `json:"value"`
	operator string
	path     string

	_rawJSON json.RawMessage
}

func (l *ListFilter) Operator() string {
	return l.operator
}

func (l *ListFilter) Path() string {
	return l.path
}

func (l *ListFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ListFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListFilter(value)
	l.operator = "MEMBER_OF"
	l.path = "account_id"
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListFilter) MarshalJSON() ([]byte, error) {
	type embed ListFilter
	var marshaler = struct {
		embed
		Operator string `json:"operator"`
		Path     string `json:"path"`
	}{
		embed:    embed(*l),
		Operator: "MEMBER_OF",
		Path:     "account_id",
	}
	return json.Marshal(marshaler)
}

func (l *ListFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPatternRecipient struct {
	ListPattern *string      `json:"list_pattern,omitempty"`
	Data        *MessageData `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListPatternRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPatternRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPatternRecipient(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPatternRecipient) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPatternRecipientType struct {
	_rawJSON json.RawMessage
}

func (l *ListPatternRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPatternRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPatternRecipientType(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPatternRecipientType) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListRecipient struct {
	ListId  *string       `json:"list_id,omitempty"`
	Data    *MessageData  `json:"data,omitempty"`
	Filters []*ListFilter `json:"filters,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRecipient(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRecipient) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListRecipientType struct {
	_rawJSON json.RawMessage
}

func (l *ListRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRecipientType(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRecipientType) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Locale struct {
	Content string `json:"content"`

	_rawJSON json.RawMessage
}

func (l *Locale) UnmarshalJSON(data []byte) error {
	type unmarshaler Locale
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Locale(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Locale) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Locales = map[string]*Locale

type Logo struct {
	Href  *string `json:"href,omitempty"`
	Image *string `json:"image,omitempty"`

	_rawJSON json.RawMessage
}

func (l *Logo) UnmarshalJSON(data []byte) error {
	type unmarshaler Logo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Logo(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Logo) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Message struct {
	typeName string
	// Describes the content of the message in a way that will work for email, push, chat, or any channel.
	ContentMessage *ContentMessage
	// A template for a type of message that can be sent more than once. For example, you might create an "Appointment Reminder" Notification or “Reset Password” Notifications.
	TemplateMessage *TemplateMessage
}

func NewMessageFromContentMessage(value *ContentMessage) *Message {
	return &Message{typeName: "contentMessage", ContentMessage: value}
}

func NewMessageFromTemplateMessage(value *TemplateMessage) *Message {
	return &Message{typeName: "templateMessage", TemplateMessage: value}
}

func (m *Message) UnmarshalJSON(data []byte) error {
	valueContentMessage := new(ContentMessage)
	if err := json.Unmarshal(data, &valueContentMessage); err == nil {
		m.typeName = "contentMessage"
		m.ContentMessage = valueContentMessage
		return nil
	}
	valueTemplateMessage := new(TemplateMessage)
	if err := json.Unmarshal(data, &valueTemplateMessage); err == nil {
		m.typeName = "templateMessage"
		m.TemplateMessage = valueTemplateMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m Message) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "contentMessage":
		return json.Marshal(m.ContentMessage)
	case "templateMessage":
		return json.Marshal(m.TemplateMessage)
	}
}

type MessageVisitor interface {
	VisitContentMessage(*ContentMessage) error
	VisitTemplateMessage(*TemplateMessage) error
}

func (m *Message) Accept(visitor MessageVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "contentMessage":
		return visitor.VisitContentMessage(m.ContentMessage)
	case "templateMessage":
		return visitor.VisitTemplateMessage(m.TemplateMessage)
	}
}

type MessageChannelEmailOverride struct {
	Attachments []Attachment      `json:"attachments,omitempty"`
	Bcc         *string           `json:"bcc,omitempty"`
	Brand       *Brand            `json:"brand,omitempty"`
	Cc          *string           `json:"cc,omitempty"`
	From        *string           `json:"from,omitempty"`
	Html        *string           `json:"html,omitempty"`
	ReplyTo     *string           `json:"reply_to,omitempty"`
	Subject     *string           `json:"subject,omitempty"`
	Text        *string           `json:"text,omitempty"`
	Tracking    *TrackingOverride `json:"tracking,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageChannelEmailOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageChannelEmailOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageChannelEmailOverride(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageChannelEmailOverride) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageChannels = map[string]*Channel

type MessageContext struct {
	// An id of a tenant, see [tenants api docs](https://www.courier.com/docs/reference/tenants/).
	// Will load brand, default preferences and any other base context data associated with this tenant.
	TenantId *string `json:"tenant_id,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageContext) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageContext(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageContext) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageData = map[string]interface{}

type MessageMetadata struct {
	// An arbitrary string to tracks the event that generated this request (e.g. 'signup').
	Event *string `json:"event,omitempty"`
	// An array of up to 9 tags you wish to associate with this request (and corresponding messages) for later analysis. Individual tags cannot be more than 30 characters in length.
	Tags []string `json:"tags,omitempty"`
	// Identify the campaign that refers traffic to a specific website, and attributes the browser's website session.
	Utm *Utm `json:"utm,omitempty"`
	// A unique ID used to correlate this request to processing on your servers. Note: Courier does not verify the uniqueness of this ID.
	TraceId *string `json:"trace_id,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageMetadata(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageMetadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageProviders = map[string]*MessageProvidersType

type MessageProvidersType struct {
	// Provider specific overrides.
	Override map[string]interface{} `json:"override,omitempty"`
	// A JavaScript conditional expression to determine if the message should be sent
	// through the channel. Has access to the data and profile object. For example,
	// `data.name === profile.name`
	If       *string   `json:"if,omitempty"`
	Timeouts *int      `json:"timeouts,omitempty"`
	Metadata *Metadata `json:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MessageProvidersType) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageProvidersType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageProvidersType(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageProvidersType) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageRecipient struct {
	typeName      string
	Recipient     *Recipient
	RecipientList []*Recipient
}

func NewMessageRecipientFromRecipient(value *Recipient) *MessageRecipient {
	return &MessageRecipient{typeName: "recipient", Recipient: value}
}

func NewMessageRecipientFromRecipientList(value []*Recipient) *MessageRecipient {
	return &MessageRecipient{typeName: "recipientList", RecipientList: value}
}

func (m *MessageRecipient) UnmarshalJSON(data []byte) error {
	valueRecipient := new(Recipient)
	if err := json.Unmarshal(data, &valueRecipient); err == nil {
		m.typeName = "recipient"
		m.Recipient = valueRecipient
		return nil
	}
	var valueRecipientList []*Recipient
	if err := json.Unmarshal(data, &valueRecipientList); err == nil {
		m.typeName = "recipientList"
		m.RecipientList = valueRecipientList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MessageRecipient) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "recipient":
		return json.Marshal(m.Recipient)
	case "recipientList":
		return json.Marshal(m.RecipientList)
	}
}

type MessageRecipientVisitor interface {
	VisitRecipient(*Recipient) error
	VisitRecipientList([]*Recipient) error
}

func (m *MessageRecipient) Accept(visitor MessageRecipientVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "recipient":
		return visitor.VisitRecipient(m.Recipient)
	case "recipientList":
		return visitor.VisitRecipientList(m.RecipientList)
	}
}

type Metadata struct {
	Utm *Utm `json:"utm,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MsTeamsRecipient struct {
	MsTeams *MsTeams `json:"ms_teams,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MsTeamsRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler MsTeamsRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MsTeamsRecipient(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MsTeamsRecipient) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Override string

const (
	OverrideMessageChannelEmailOverride Override = "MessageChannelEmailOverride"
	OverrideMessageChannelPushOverride  Override = "MessageChannelPushOverride"
)

func NewOverrideFromString(s string) (Override, error) {
	switch s {
	case "MessageChannelEmailOverride":
		return OverrideMessageChannelEmailOverride, nil
	case "MessageChannelPushOverride":
		return OverrideMessageChannelPushOverride, nil
	}
	var t Override
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Override) Ptr() *Override {
	return &o
}

type Preference struct {
	Status             PreferenceStatus     `json:"status,omitempty"`
	Rules              []*Rule              `json:"rules,omitempty"`
	ChannelPreferences []*ChannelPreference `json:"channel_preferences,omitempty"`
	Source             *ChannelSource       `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Preference) UnmarshalJSON(data []byte) error {
	type unmarshaler Preference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Preference(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Preference) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Preferences struct {
	TemplateIds []string `json:"templateIds,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Preferences) UnmarshalJSON(data []byte) error {
	type unmarshaler Preferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Preferences(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Preferences) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Recipient struct {
	typeName             string
	AudienceRecipient    *AudienceRecipient
	ListRecipient        *ListRecipient
	ListPatternRecipient *ListPatternRecipient
	UserRecipient        *UserRecipient
	SlackRecipient       *SlackRecipient
	MsTeamsRecipient     *MsTeamsRecipient
}

func NewRecipientFromAudienceRecipient(value *AudienceRecipient) *Recipient {
	return &Recipient{typeName: "audienceRecipient", AudienceRecipient: value}
}

func NewRecipientFromListRecipient(value *ListRecipient) *Recipient {
	return &Recipient{typeName: "listRecipient", ListRecipient: value}
}

func NewRecipientFromListPatternRecipient(value *ListPatternRecipient) *Recipient {
	return &Recipient{typeName: "listPatternRecipient", ListPatternRecipient: value}
}

func NewRecipientFromUserRecipient(value *UserRecipient) *Recipient {
	return &Recipient{typeName: "userRecipient", UserRecipient: value}
}

func NewRecipientFromSlackRecipient(value *SlackRecipient) *Recipient {
	return &Recipient{typeName: "slackRecipient", SlackRecipient: value}
}

func NewRecipientFromMsTeamsRecipient(value *MsTeamsRecipient) *Recipient {
	return &Recipient{typeName: "msTeamsRecipient", MsTeamsRecipient: value}
}

func (r *Recipient) UnmarshalJSON(data []byte) error {
	valueAudienceRecipient := new(AudienceRecipient)
	if err := json.Unmarshal(data, &valueAudienceRecipient); err == nil {
		r.typeName = "audienceRecipient"
		r.AudienceRecipient = valueAudienceRecipient
		return nil
	}
	valueListRecipient := new(ListRecipient)
	if err := json.Unmarshal(data, &valueListRecipient); err == nil {
		r.typeName = "listRecipient"
		r.ListRecipient = valueListRecipient
		return nil
	}
	valueListPatternRecipient := new(ListPatternRecipient)
	if err := json.Unmarshal(data, &valueListPatternRecipient); err == nil {
		r.typeName = "listPatternRecipient"
		r.ListPatternRecipient = valueListPatternRecipient
		return nil
	}
	valueUserRecipient := new(UserRecipient)
	if err := json.Unmarshal(data, &valueUserRecipient); err == nil {
		r.typeName = "userRecipient"
		r.UserRecipient = valueUserRecipient
		return nil
	}
	valueSlackRecipient := new(SlackRecipient)
	if err := json.Unmarshal(data, &valueSlackRecipient); err == nil {
		r.typeName = "slackRecipient"
		r.SlackRecipient = valueSlackRecipient
		return nil
	}
	valueMsTeamsRecipient := new(MsTeamsRecipient)
	if err := json.Unmarshal(data, &valueMsTeamsRecipient); err == nil {
		r.typeName = "msTeamsRecipient"
		r.MsTeamsRecipient = valueMsTeamsRecipient
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Recipient) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "audienceRecipient":
		return json.Marshal(r.AudienceRecipient)
	case "listRecipient":
		return json.Marshal(r.ListRecipient)
	case "listPatternRecipient":
		return json.Marshal(r.ListPatternRecipient)
	case "userRecipient":
		return json.Marshal(r.UserRecipient)
	case "slackRecipient":
		return json.Marshal(r.SlackRecipient)
	case "msTeamsRecipient":
		return json.Marshal(r.MsTeamsRecipient)
	}
}

type RecipientVisitor interface {
	VisitAudienceRecipient(*AudienceRecipient) error
	VisitListRecipient(*ListRecipient) error
	VisitListPatternRecipient(*ListPatternRecipient) error
	VisitUserRecipient(*UserRecipient) error
	VisitSlackRecipient(*SlackRecipient) error
	VisitMsTeamsRecipient(*MsTeamsRecipient) error
}

func (r *Recipient) Accept(visitor RecipientVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "audienceRecipient":
		return visitor.VisitAudienceRecipient(r.AudienceRecipient)
	case "listRecipient":
		return visitor.VisitListRecipient(r.ListRecipient)
	case "listPatternRecipient":
		return visitor.VisitListPatternRecipient(r.ListPatternRecipient)
	case "userRecipient":
		return visitor.VisitUserRecipient(r.UserRecipient)
	case "slackRecipient":
		return visitor.VisitSlackRecipient(r.SlackRecipient)
	case "msTeamsRecipient":
		return visitor.VisitMsTeamsRecipient(r.MsTeamsRecipient)
	}
}

// Allows you to customize which channel(s) Courier will potentially deliver the message.
// If no routing key is specified, Courier will use the default routing configuration or
// routing defined by the template.
type Routing struct {
	Method RoutingMethod `json:"method,omitempty"`
	// A list of channels or providers to send the message through. Can also recursively define
	// sub-routing methods, which can be useful for defining advanced push notification
	// delivery strategies.
	Channels []*RoutingChannel `json:"channels,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Routing) UnmarshalJSON(data []byte) error {
	type unmarshaler Routing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Routing(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Routing) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoutingChannel struct {
	typeName                string
	RoutingStrategyChannel  *RoutingStrategyChannel
	RoutingStrategyProvider *RoutingStrategyProvider
	String                  string
}

func NewRoutingChannelFromRoutingStrategyChannel(value *RoutingStrategyChannel) *RoutingChannel {
	return &RoutingChannel{typeName: "routingStrategyChannel", RoutingStrategyChannel: value}
}

func NewRoutingChannelFromRoutingStrategyProvider(value *RoutingStrategyProvider) *RoutingChannel {
	return &RoutingChannel{typeName: "routingStrategyProvider", RoutingStrategyProvider: value}
}

func NewRoutingChannelFromString(value string) *RoutingChannel {
	return &RoutingChannel{typeName: "string", String: value}
}

func (r *RoutingChannel) UnmarshalJSON(data []byte) error {
	valueRoutingStrategyChannel := new(RoutingStrategyChannel)
	if err := json.Unmarshal(data, &valueRoutingStrategyChannel); err == nil {
		r.typeName = "routingStrategyChannel"
		r.RoutingStrategyChannel = valueRoutingStrategyChannel
		return nil
	}
	valueRoutingStrategyProvider := new(RoutingStrategyProvider)
	if err := json.Unmarshal(data, &valueRoutingStrategyProvider); err == nil {
		r.typeName = "routingStrategyProvider"
		r.RoutingStrategyProvider = valueRoutingStrategyProvider
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RoutingChannel) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "routingStrategyChannel":
		return json.Marshal(r.RoutingStrategyChannel)
	case "routingStrategyProvider":
		return json.Marshal(r.RoutingStrategyProvider)
	case "string":
		return json.Marshal(r.String)
	}
}

type RoutingChannelVisitor interface {
	VisitRoutingStrategyChannel(*RoutingStrategyChannel) error
	VisitRoutingStrategyProvider(*RoutingStrategyProvider) error
	VisitString(string) error
}

func (r *RoutingChannel) Accept(visitor RoutingChannelVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "routingStrategyChannel":
		return visitor.VisitRoutingStrategyChannel(r.RoutingStrategyChannel)
	case "routingStrategyProvider":
		return visitor.VisitRoutingStrategyProvider(r.RoutingStrategyProvider)
	case "string":
		return visitor.VisitString(r.String)
	}
}

type RoutingMethod string

const (
	RoutingMethodAll    RoutingMethod = "all"
	RoutingMethodSingle RoutingMethod = "single"
)

func NewRoutingMethodFromString(s string) (RoutingMethod, error) {
	switch s {
	case "all":
		return RoutingMethodAll, nil
	case "single":
		return RoutingMethodSingle, nil
	}
	var t RoutingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoutingMethod) Ptr() *RoutingMethod {
	return &r
}

type RoutingStrategyChannel struct {
	Channel   string                 `json:"channel"`
	Config    map[string]interface{} `json:"config,omitempty"`
	Method    *RoutingMethod         `json:"method,omitempty"`
	Providers *MessageProviders      `json:"providers,omitempty"`
	If        *string                `json:"if,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoutingStrategyChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler RoutingStrategyChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoutingStrategyChannel(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoutingStrategyChannel) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoutingStrategyProvider struct {
	Name     string                 `json:"name"`
	Config   map[string]interface{} `json:"config,omitempty"`
	If       *string                `json:"if,omitempty"`
	Metadata *Metadata              `json:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoutingStrategyProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler RoutingStrategyProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoutingStrategyProvider(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoutingStrategyProvider) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RuleType string

const (
	RuleTypeSnooze             RuleType = "snooze"
	RuleTypeChannelPreferences RuleType = "channel_preferences"
	RuleTypeStatus             RuleType = "status"
)

func NewRuleTypeFromString(s string) (RuleType, error) {
	switch s {
	case "snooze":
		return RuleTypeSnooze, nil
	case "channel_preferences":
		return RuleTypeChannelPreferences, nil
	case "status":
		return RuleTypeStatus, nil
	}
	var t RuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleType) Ptr() *RuleType {
	return &r
}

type SlackRecipient struct {
	Slack *Slack `json:"slack,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SlackRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler SlackRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlackRecipient(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackRecipient) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TemplateMessage struct {
	// An arbitrary object that includes any data you want to pass to the message.
	// The data will populate the corresponding template or elements variables.
	Data    *MessageData `json:"data,omitempty"`
	BrandId *string      `json:"brand_id,omitempty"`
	// "Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook."
	Channels *MessageChannels `json:"channels,omitempty"`
	// Context to load with this recipient. Will override any context set on message.context.
	Context *MessageContext `json:"context,omitempty"`
	// Metadata such as utm tracking attached with the notification through this channel.
	Metadata *MessageMetadata `json:"metadata,omitempty"`
	// An object whose keys are valid provider identifiers which map to an object.
	Providers *MessageProviders `json:"providers,omitempty"`
	Routing   *Routing          `json:"routing,omitempty"`
	// Time in ms to attempt the channel before failing over to the next available channel.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Defines the time to wait before delivering the message.
	Delay *Delay `json:"delay,omitempty"`
	// "Expiry allows you to set an absolute or relative time in which a message expires.
	// Note: This is only valid for the Courier Inbox channel as of 12-08-2022."
	Expiry *Expiry `json:"expiry,omitempty"`
	// The id of the notification template to be rendered and sent to the recipient(s).
	// This field or the content field must be supplied.
	Template string `json:"template"`
	// The recipient or a list of recipients of the message
	To *MessageRecipient `json:"to,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TemplateMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler TemplateMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TemplateMessage(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TemplateMessage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextAlign string

const (
	TextAlignLeft   TextAlign = "left"
	TextAlignCenter TextAlign = "center"
	TextAlignRight  TextAlign = "right"
)

func NewTextAlignFromString(s string) (TextAlign, error) {
	switch s {
	case "left":
		return TextAlignLeft, nil
	case "center":
		return TextAlignCenter, nil
	case "right":
		return TextAlignRight, nil
	}
	var t TextAlign
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextAlign) Ptr() *TextAlign {
	return &t
}

type TextStyle string

const (
	TextStyleText    TextStyle = "text"
	TextStyleH1      TextStyle = "h1"
	TextStyleH2      TextStyle = "h2"
	TextStyleSubtext TextStyle = "subtext"
)

func NewTextStyleFromString(s string) (TextStyle, error) {
	switch s {
	case "text":
		return TextStyleText, nil
	case "h1":
		return TextStyleH1, nil
	case "h2":
		return TextStyleH2, nil
	case "subtext":
		return TextStyleSubtext, nil
	}
	var t TextStyle
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextStyle) Ptr() *TextStyle {
	return &t
}

type Timeout struct {
	Provider   map[string]int `json:"provider,omitempty"`
	Channel    map[string]int `json:"channel,omitempty"`
	Message    *int           `json:"message,omitempty"`
	Escalation *int           `json:"escalation,omitempty"`
	Criteria   *Criteria      `json:"criteria,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Timeout) UnmarshalJSON(data []byte) error {
	type unmarshaler Timeout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Timeout(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Timeout) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Timeouts struct {
	Provider *int `json:"provider,omitempty"`
	Channel  *int `json:"channel,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Timeouts) UnmarshalJSON(data []byte) error {
	type unmarshaler Timeouts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Timeouts(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Timeouts) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TrackingOverride struct {
	Open bool `json:"open"`

	_rawJSON json.RawMessage
}

func (t *TrackingOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler TrackingOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrackingOverride(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrackingOverride) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Utm struct {
	Source   *string `json:"source,omitempty"`
	Medium   *string `json:"medium,omitempty"`
	Campaign *string `json:"campaign,omitempty"`
	Term     *string `json:"term,omitempty"`
	Content  *string `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (u *Utm) UnmarshalJSON(data []byte) error {
	type unmarshaler Utm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Utm(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *Utm) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRecipient struct {
	// Use `tenant_id` instad.
	AccountId *string `json:"account_id,omitempty"`
	// Context information such as tenant_id to send the notification with.
	Context *MessageContext `json:"context,omitempty"`
	Data    *MessageData    `json:"data,omitempty"`
	Email   *string         `json:"email,omitempty"`
	// The user's preferred ISO 639-1 language code.
	Locale      *string              `json:"locale,omitempty"`
	UserId      *string              `json:"user_id,omitempty"`
	PhoneNumber *string              `json:"phone_number,omitempty"`
	Preferences *IProfilePreferences `json:"preferences,omitempty"`
	// An id of a tenant, [see tenants api docs](https://www.courier.com/docs/reference/tenants).
	// Will load brand, default preferences and any other base context data associated with this tenant.
	TenantId *string `json:"tenant_id,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRecipient(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRecipient) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRecipientType struct {
	_rawJSON json.RawMessage
}

func (u *UserRecipientType) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRecipientType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRecipientType(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRecipientType) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type WidgetBackground struct {
	TopColor    *string `json:"topColor,omitempty"`
	BottomColor *string `json:"bottomColor,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WidgetBackground) UnmarshalJSON(data []byte) error {
	type unmarshaler WidgetBackground
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WidgetBackground(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WidgetBackground) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ChannelIdentifier = string

type NotificationTemplates struct {
	// A UTC timestamp at which notification was created. This is stored as a millisecond representation of the Unix epoch (the time passed since January 1, 1970).
	CreatedAt int `json:"created_at"`
	// A unique identifier associated with the notification.
	Id string `json:"id"`
	// Routing strategy used by this notification.
	Routing *RoutingStrategy `json:"routing,omitempty"`
	// A list of tags attached to the notification.
	Tags []*Tag `json:"tags,omitempty"`
	// The title of the notification.
	Title string `json:"title"`
	// A UTC timestamp at which notification was updated. This is stored as a millisecond representation of the Unix epoch (the time passed since January 1, 1970).
	UpdatedAt int `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (n *NotificationTemplates) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationTemplates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationTemplates(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationTemplates) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type RoutingStrategy struct {
	// The method for selecting channels to send the message with. Value can be either 'single' or 'all'. If not provided will default to 'single'
	Method RoutingStrategyMethod `json:"method,omitempty"`
	// An array of valid channel identifiers (like email, push, sms, etc.) and additional routing nodes.
	Channels []ChannelIdentifier `json:"channels,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoutingStrategy) UnmarshalJSON(data []byte) error {
	type unmarshaler RoutingStrategy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoutingStrategy(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoutingStrategy) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoutingStrategyMethod string

const (
	RoutingStrategyMethodAll    RoutingStrategyMethod = "all"
	RoutingStrategyMethodSingle RoutingStrategyMethod = "single"
)

func NewRoutingStrategyMethodFromString(s string) (RoutingStrategyMethod, error) {
	switch s {
	case "all":
		return RoutingStrategyMethodAll, nil
	case "single":
		return RoutingStrategyMethodSingle, nil
	}
	var t RoutingStrategyMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoutingStrategyMethod) Ptr() *RoutingStrategyMethod {
	return &r
}

type Tag struct {
	Data []*TagData `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Tag) UnmarshalJSON(data []byte) error {
	type unmarshaler Tag
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tag(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tag) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TagData struct {
	// A unique identifier of the tag.
	Id string `json:"id"`
	// Name of the tag.
	Name string `json:"name"`

	_rawJSON json.RawMessage
}

func (t *TagData) UnmarshalJSON(data []byte) error {
	type unmarshaler TagData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TagData(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TagData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type SubscriptionTopic struct {
	// Topic ID
	Id     string                  `json:"id"`
	Status SubscriptionTopicStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SubscriptionTopic) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionTopic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionTopic(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionTopic) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionTopicStatus string

const (
	SubscriptionTopicStatusOptedOut SubscriptionTopicStatus = "OPTED_OUT"
	SubscriptionTopicStatusOptedIn  SubscriptionTopicStatus = "OPTED_IN"
	SubscriptionTopicStatusRequired SubscriptionTopicStatus = "REQUIRED"
)

func NewSubscriptionTopicStatusFromString(s string) (SubscriptionTopicStatus, error) {
	switch s {
	case "OPTED_OUT":
		return SubscriptionTopicStatusOptedOut, nil
	case "OPTED_IN":
		return SubscriptionTopicStatusOptedIn, nil
	case "REQUIRED":
		return SubscriptionTopicStatusRequired, nil
	}
	var t SubscriptionTopicStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionTopicStatus) Ptr() *SubscriptionTopicStatus {
	return &s
}
