// Code generated by Fern. DO NOT EDIT.

package users

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/trycourier/courier-go/v3/internal"
	big "math/big"
)

var (
	deleteUserTokenOptsFieldUserId = big.NewInt(1 << 0)
	deleteUserTokenOptsFieldToken  = big.NewInt(1 << 1)
)

type DeleteUserTokenOpts struct {
	UserId string `json:"user_id" url:"user_id"`
	Token  string `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteUserTokenOpts) GetUserId() string {
	if d == nil {
		return ""
	}
	return d.UserId
}

func (d *DeleteUserTokenOpts) GetToken() string {
	if d == nil {
		return ""
	}
	return d.Token
}

func (d *DeleteUserTokenOpts) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteUserTokenOpts) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteUserTokenOpts) SetUserId(userId string) {
	d.UserId = userId
	d.require(deleteUserTokenOptsFieldUserId)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteUserTokenOpts) SetToken(token string) {
	d.Token = token
	d.require(deleteUserTokenOptsFieldToken)
}

func (d *DeleteUserTokenOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserTokenOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserTokenOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserTokenOpts) MarshalJSON() ([]byte, error) {
	type embed DeleteUserTokenOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteUserTokenOpts) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	deviceFieldAppId        = big.NewInt(1 << 0)
	deviceFieldAdId         = big.NewInt(1 << 1)
	deviceFieldDeviceId     = big.NewInt(1 << 2)
	deviceFieldPlatform     = big.NewInt(1 << 3)
	deviceFieldManufacturer = big.NewInt(1 << 4)
	deviceFieldModel        = big.NewInt(1 << 5)
)

type Device struct {
	// Id of the application the token is used for
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// Id of the advertising identifier
	AdId *string `json:"ad_id,omitempty" url:"ad_id,omitempty"`
	// Id of the device the token is associated with
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The device platform i.e. android, ios, web
	Platform *string `json:"platform,omitempty" url:"platform,omitempty"`
	// The device manufacturer
	Manufacturer *string `json:"manufacturer,omitempty" url:"manufacturer,omitempty"`
	// The device model
	Model *string `json:"model,omitempty" url:"model,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Device) GetAppId() *string {
	if d == nil {
		return nil
	}
	return d.AppId
}

func (d *Device) GetAdId() *string {
	if d == nil {
		return nil
	}
	return d.AdId
}

func (d *Device) GetDeviceId() *string {
	if d == nil {
		return nil
	}
	return d.DeviceId
}

func (d *Device) GetPlatform() *string {
	if d == nil {
		return nil
	}
	return d.Platform
}

func (d *Device) GetManufacturer() *string {
	if d == nil {
		return nil
	}
	return d.Manufacturer
}

func (d *Device) GetModel() *string {
	if d == nil {
		return nil
	}
	return d.Model
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetAppId(appId *string) {
	d.AppId = appId
	d.require(deviceFieldAppId)
}

// SetAdId sets the AdId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetAdId(adId *string) {
	d.AdId = adId
	d.require(deviceFieldAdId)
}

// SetDeviceId sets the DeviceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetDeviceId(deviceId *string) {
	d.DeviceId = deviceId
	d.require(deviceFieldDeviceId)
}

// SetPlatform sets the Platform field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetPlatform(platform *string) {
	d.Platform = platform
	d.require(deviceFieldPlatform)
}

// SetManufacturer sets the Manufacturer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetManufacturer(manufacturer *string) {
	d.Manufacturer = manufacturer
	d.require(deviceFieldManufacturer)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetModel(model *string) {
	d.Model = model
	d.require(deviceFieldModel)
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type unmarshaler Device
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Device(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Device) MarshalJSON() ([]byte, error) {
	type embed Device
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Device) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ExpiryDate struct {
	String  string
	Boolean bool

	typ string
}

func (e *ExpiryDate) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *ExpiryDate) GetBoolean() bool {
	if e == nil {
		return false
	}
	return e.Boolean
}

func (e *ExpiryDate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		e.typ = "Boolean"
		e.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpiryDate) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Boolean" || e.Boolean != false {
		return json.Marshal(e.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ExpiryDateVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (e *ExpiryDate) Accept(visitor ExpiryDateVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Boolean" || e.Boolean != false {
		return visitor.VisitBoolean(e.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// A list of tokens registered with the user.
type GetAllTokensResponse = []*UserToken

var (
	getUserTokenOptsFieldUserId = big.NewInt(1 << 0)
	getUserTokenOptsFieldToken  = big.NewInt(1 << 1)
)

type GetUserTokenOpts struct {
	UserId string `json:"user_id" url:"user_id"`
	Token  string `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetUserTokenOpts) GetUserId() string {
	if g == nil {
		return ""
	}
	return g.UserId
}

func (g *GetUserTokenOpts) GetToken() string {
	if g == nil {
		return ""
	}
	return g.Token
}

func (g *GetUserTokenOpts) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetUserTokenOpts) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenOpts) SetUserId(userId string) {
	g.UserId = userId
	g.require(getUserTokenOptsFieldUserId)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenOpts) SetToken(token string) {
	g.Token = token
	g.require(getUserTokenOptsFieldToken)
}

func (g *GetUserTokenOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserTokenOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserTokenOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserTokenOpts) MarshalJSON() ([]byte, error) {
	type embed GetUserTokenOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetUserTokenOpts) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	getUserTokenResponseFieldToken        = big.NewInt(1 << 0)
	getUserTokenResponseFieldProviderKey  = big.NewInt(1 << 1)
	getUserTokenResponseFieldExpiryDate   = big.NewInt(1 << 2)
	getUserTokenResponseFieldProperties   = big.NewInt(1 << 3)
	getUserTokenResponseFieldDevice       = big.NewInt(1 << 4)
	getUserTokenResponseFieldTracking     = big.NewInt(1 << 5)
	getUserTokenResponseFieldStatus       = big.NewInt(1 << 6)
	getUserTokenResponseFieldStatusReason = big.NewInt(1 << 7)
)

type GetUserTokenResponse struct {
	// Full body of the token. Must match token in URL.
	Token       *string     `json:"token,omitempty" url:"token,omitempty"`
	ProviderKey ProviderKey `json:"provider_key" url:"provider_key"`
	// ISO 8601 formatted date the token expires. Defaults to 2 months. Set to false to disable expiration.
	ExpiryDate *ExpiryDate `json:"expiry_date,omitempty" url:"expiry_date,omitempty"`
	// Properties sent to the provider along with the token
	Properties interface{} `json:"properties,omitempty" url:"properties,omitempty"`
	// Information about the device the token is associated with.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// Information about the device the token is associated with.
	Tracking *Tracking    `json:"tracking,omitempty" url:"tracking,omitempty"`
	Status   *TokenStatus `json:"status,omitempty" url:"status,omitempty"`
	// The reason for the token status.
	StatusReason *string `json:"status_reason,omitempty" url:"status_reason,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetUserTokenResponse) GetToken() *string {
	if g == nil {
		return nil
	}
	return g.Token
}

func (g *GetUserTokenResponse) GetProviderKey() ProviderKey {
	if g == nil {
		return ""
	}
	return g.ProviderKey
}

func (g *GetUserTokenResponse) GetExpiryDate() *ExpiryDate {
	if g == nil {
		return nil
	}
	return g.ExpiryDate
}

func (g *GetUserTokenResponse) GetProperties() interface{} {
	if g == nil {
		return nil
	}
	return g.Properties
}

func (g *GetUserTokenResponse) GetDevice() *Device {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetUserTokenResponse) GetTracking() *Tracking {
	if g == nil {
		return nil
	}
	return g.Tracking
}

func (g *GetUserTokenResponse) GetStatus() *TokenStatus {
	if g == nil {
		return nil
	}
	return g.Status
}

func (g *GetUserTokenResponse) GetStatusReason() *string {
	if g == nil {
		return nil
	}
	return g.StatusReason
}

func (g *GetUserTokenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetUserTokenResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetToken(token *string) {
	g.Token = token
	g.require(getUserTokenResponseFieldToken)
}

// SetProviderKey sets the ProviderKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetProviderKey(providerKey ProviderKey) {
	g.ProviderKey = providerKey
	g.require(getUserTokenResponseFieldProviderKey)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetExpiryDate(expiryDate *ExpiryDate) {
	g.ExpiryDate = expiryDate
	g.require(getUserTokenResponseFieldExpiryDate)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetProperties(properties interface{}) {
	g.Properties = properties
	g.require(getUserTokenResponseFieldProperties)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetDevice(device *Device) {
	g.Device = device
	g.require(getUserTokenResponseFieldDevice)
}

// SetTracking sets the Tracking field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetTracking(tracking *Tracking) {
	g.Tracking = tracking
	g.require(getUserTokenResponseFieldTracking)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetStatus(status *TokenStatus) {
	g.Status = status
	g.require(getUserTokenResponseFieldStatus)
}

// SetStatusReason sets the StatusReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokenResponse) SetStatusReason(statusReason *string) {
	g.StatusReason = statusReason
	g.require(getUserTokenResponseFieldStatusReason)
}

func (g *GetUserTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserTokenResponse) MarshalJSON() ([]byte, error) {
	type embed GetUserTokenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetUserTokenResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	getUserTokensOptsFieldUserId = big.NewInt(1 << 0)
)

type GetUserTokensOpts struct {
	UserId string `json:"user_id" url:"user_id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetUserTokensOpts) GetUserId() string {
	if g == nil {
		return ""
	}
	return g.UserId
}

func (g *GetUserTokensOpts) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetUserTokensOpts) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetUserTokensOpts) SetUserId(userId string) {
	g.UserId = userId
	g.require(getUserTokensOptsFieldUserId)
}

func (g *GetUserTokensOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserTokensOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserTokensOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserTokensOpts) MarshalJSON() ([]byte, error) {
	type embed GetUserTokensOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetUserTokensOpts) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchOp string

const (
	PatchOpReplace PatchOp = "replace"
	PatchOpAdd     PatchOp = "add"
	PatchOpRemove  PatchOp = "remove"
	PatchOpCopy    PatchOp = "copy"
	PatchOpMove    PatchOp = "move"
	PatchOpTest    PatchOp = "test"
)

func NewPatchOpFromString(s string) (PatchOp, error) {
	switch s {
	case "replace":
		return PatchOpReplace, nil
	case "add":
		return PatchOpAdd, nil
	case "remove":
		return PatchOpRemove, nil
	case "copy":
		return PatchOpCopy, nil
	case "move":
		return PatchOpMove, nil
	case "test":
		return PatchOpTest, nil
	}
	var t PatchOp
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PatchOp) Ptr() *PatchOp {
	return &p
}

var (
	patchOperationFieldOp    = big.NewInt(1 << 0)
	patchOperationFieldPath  = big.NewInt(1 << 1)
	patchOperationFieldValue = big.NewInt(1 << 2)
)

type PatchOperation struct {
	// The operation to perform.
	Op string `json:"op" url:"op"`
	// The JSON path specifying the part of the profile to operate on.
	Path string `json:"path" url:"path"`
	// The value for the operation.
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchOperation) GetOp() string {
	if p == nil {
		return ""
	}
	return p.Op
}

func (p *PatchOperation) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchOperation) GetValue() *string {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PatchOperation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchOperation) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOp sets the Op field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchOperation) SetOp(op string) {
	p.Op = op
	p.require(patchOperationFieldOp)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchOperation) SetPath(path string) {
	p.Path = path
	p.require(patchOperationFieldPath)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchOperation) SetValue(value *string) {
	p.Value = value
	p.require(patchOperationFieldValue)
}

func (p *PatchOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchOperation) MarshalJSON() ([]byte, error) {
	type embed PatchOperation
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchOperation) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	patchUserTokenOptsFieldPatch = big.NewInt(1 << 0)
)

type PatchUserTokenOpts struct {
	Patch []*PatchOperation `json:"patch" url:"patch"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchUserTokenOpts) GetPatch() []*PatchOperation {
	if p == nil {
		return nil
	}
	return p.Patch
}

func (p *PatchUserTokenOpts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchUserTokenOpts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPatch sets the Patch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchUserTokenOpts) SetPatch(patch []*PatchOperation) {
	p.Patch = patch
	p.require(patchUserTokenOptsFieldPatch)
}

func (p *PatchUserTokenOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserTokenOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserTokenOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserTokenOpts) MarshalJSON() ([]byte, error) {
	type embed PatchUserTokenOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchUserTokenOpts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderKey string

const (
	ProviderKeyFirebaseFcm ProviderKey = "firebase-fcm"
	ProviderKeyApn         ProviderKey = "apn"
	ProviderKeyExpo        ProviderKey = "expo"
	ProviderKeyOnesignal   ProviderKey = "onesignal"
)

func NewProviderKeyFromString(s string) (ProviderKey, error) {
	switch s {
	case "firebase-fcm":
		return ProviderKeyFirebaseFcm, nil
	case "apn":
		return ProviderKeyApn, nil
	case "expo":
		return ProviderKeyExpo, nil
	case "onesignal":
		return ProviderKeyOnesignal, nil
	}
	var t ProviderKey
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderKey) Ptr() *ProviderKey {
	return &p
}

var (
	putUserTokenOptsFieldUserId = big.NewInt(1 << 0)
	putUserTokenOptsFieldToken  = big.NewInt(1 << 1)
)

type PutUserTokenOpts struct {
	UserId string     `json:"user_id" url:"user_id"`
	Token  *UserToken `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PutUserTokenOpts) GetUserId() string {
	if p == nil {
		return ""
	}
	return p.UserId
}

func (p *PutUserTokenOpts) GetToken() *UserToken {
	if p == nil {
		return nil
	}
	return p.Token
}

func (p *PutUserTokenOpts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PutUserTokenOpts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PutUserTokenOpts) SetUserId(userId string) {
	p.UserId = userId
	p.require(putUserTokenOptsFieldUserId)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PutUserTokenOpts) SetToken(token *UserToken) {
	p.Token = token
	p.require(putUserTokenOptsFieldToken)
}

func (p *PutUserTokenOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserTokenOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserTokenOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserTokenOpts) MarshalJSON() ([]byte, error) {
	type embed PutUserTokenOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PutUserTokenOpts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	putUserTokensOptsFieldUserId = big.NewInt(1 << 0)
	putUserTokensOptsFieldTokens = big.NewInt(1 << 1)
)

type PutUserTokensOpts struct {
	UserId string       `json:"user_id" url:"user_id"`
	Tokens []*UserToken `json:"tokens" url:"tokens"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PutUserTokensOpts) GetUserId() string {
	if p == nil {
		return ""
	}
	return p.UserId
}

func (p *PutUserTokensOpts) GetTokens() []*UserToken {
	if p == nil {
		return nil
	}
	return p.Tokens
}

func (p *PutUserTokensOpts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PutUserTokensOpts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PutUserTokensOpts) SetUserId(userId string) {
	p.UserId = userId
	p.require(putUserTokensOptsFieldUserId)
}

// SetTokens sets the Tokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PutUserTokensOpts) SetTokens(tokens []*UserToken) {
	p.Tokens = tokens
	p.require(putUserTokensOptsFieldTokens)
}

func (p *PutUserTokensOpts) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserTokensOpts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserTokensOpts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserTokensOpts) MarshalJSON() ([]byte, error) {
	type embed PutUserTokensOpts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PutUserTokensOpts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type TokenStatus string

const (
	TokenStatusActive  TokenStatus = "active"
	TokenStatusUnknown TokenStatus = "unknown"
	TokenStatusFailed  TokenStatus = "failed"
	TokenStatusRevoked TokenStatus = "revoked"
)

func NewTokenStatusFromString(s string) (TokenStatus, error) {
	switch s {
	case "active":
		return TokenStatusActive, nil
	case "unknown":
		return TokenStatusUnknown, nil
	case "failed":
		return TokenStatusFailed, nil
	case "revoked":
		return TokenStatusRevoked, nil
	}
	var t TokenStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenStatus) Ptr() *TokenStatus {
	return &t
}

var (
	trackingFieldOsVersion = big.NewInt(1 << 0)
	trackingFieldIp        = big.NewInt(1 << 1)
	trackingFieldLat       = big.NewInt(1 << 2)
	trackingFieldLong      = big.NewInt(1 << 3)
)

type Tracking struct {
	// The operating system version
	OsVersion *string `json:"os_version,omitempty" url:"os_version,omitempty"`
	// The IP address of the device
	Ip *string `json:"ip,omitempty" url:"ip,omitempty"`
	// The latitude of the device
	Lat *string `json:"lat,omitempty" url:"lat,omitempty"`
	// The longitude of the device
	Long *string `json:"long,omitempty" url:"long,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tracking) GetOsVersion() *string {
	if t == nil {
		return nil
	}
	return t.OsVersion
}

func (t *Tracking) GetIp() *string {
	if t == nil {
		return nil
	}
	return t.Ip
}

func (t *Tracking) GetLat() *string {
	if t == nil {
		return nil
	}
	return t.Lat
}

func (t *Tracking) GetLong() *string {
	if t == nil {
		return nil
	}
	return t.Long
}

func (t *Tracking) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tracking) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetOsVersion sets the OsVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tracking) SetOsVersion(osVersion *string) {
	t.OsVersion = osVersion
	t.require(trackingFieldOsVersion)
}

// SetIp sets the Ip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tracking) SetIp(ip *string) {
	t.Ip = ip
	t.require(trackingFieldIp)
}

// SetLat sets the Lat field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tracking) SetLat(lat *string) {
	t.Lat = lat
	t.require(trackingFieldLat)
}

// SetLong sets the Long field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tracking) SetLong(long *string) {
	t.Long = long
	t.require(trackingFieldLong)
}

func (t *Tracking) UnmarshalJSON(data []byte) error {
	type unmarshaler Tracking
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tracking(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tracking) MarshalJSON() ([]byte, error) {
	type embed Tracking
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tracking) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	userTokenFieldToken       = big.NewInt(1 << 0)
	userTokenFieldProviderKey = big.NewInt(1 << 1)
	userTokenFieldExpiryDate  = big.NewInt(1 << 2)
	userTokenFieldProperties  = big.NewInt(1 << 3)
	userTokenFieldDevice      = big.NewInt(1 << 4)
	userTokenFieldTracking    = big.NewInt(1 << 5)
)

type UserToken struct {
	// Full body of the token. Must match token in URL.
	Token       *string     `json:"token,omitempty" url:"token,omitempty"`
	ProviderKey ProviderKey `json:"provider_key" url:"provider_key"`
	// ISO 8601 formatted date the token expires. Defaults to 2 months. Set to false to disable expiration.
	ExpiryDate *ExpiryDate `json:"expiry_date,omitempty" url:"expiry_date,omitempty"`
	// Properties sent to the provider along with the token
	Properties interface{} `json:"properties,omitempty" url:"properties,omitempty"`
	// Information about the device the token is associated with.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// Information about the device the token is associated with.
	Tracking *Tracking `json:"tracking,omitempty" url:"tracking,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserToken) GetToken() *string {
	if u == nil {
		return nil
	}
	return u.Token
}

func (u *UserToken) GetProviderKey() ProviderKey {
	if u == nil {
		return ""
	}
	return u.ProviderKey
}

func (u *UserToken) GetExpiryDate() *ExpiryDate {
	if u == nil {
		return nil
	}
	return u.ExpiryDate
}

func (u *UserToken) GetProperties() interface{} {
	if u == nil {
		return nil
	}
	return u.Properties
}

func (u *UserToken) GetDevice() *Device {
	if u == nil {
		return nil
	}
	return u.Device
}

func (u *UserToken) GetTracking() *Tracking {
	if u == nil {
		return nil
	}
	return u.Tracking
}

func (u *UserToken) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserToken) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetToken(token *string) {
	u.Token = token
	u.require(userTokenFieldToken)
}

// SetProviderKey sets the ProviderKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetProviderKey(providerKey ProviderKey) {
	u.ProviderKey = providerKey
	u.require(userTokenFieldProviderKey)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetExpiryDate(expiryDate *ExpiryDate) {
	u.ExpiryDate = expiryDate
	u.require(userTokenFieldExpiryDate)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetProperties(properties interface{}) {
	u.Properties = properties
	u.require(userTokenFieldProperties)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetDevice(device *Device) {
	u.Device = device
	u.require(userTokenFieldDevice)
}

// SetTracking sets the Tracking field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserToken) SetTracking(tracking *Tracking) {
	u.Tracking = tracking
	u.require(userTokenFieldTracking)
}

func (u *UserToken) UnmarshalJSON(data []byte) error {
	type unmarshaler UserToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserToken) MarshalJSON() ([]byte, error) {
	type embed UserToken
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserToken) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
