// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/trycourier/courier-go/v3/internal"
	big "math/big"
)

var (
	audiencesListParamsFieldCursor = big.NewInt(1 << 0)
)

type AudiencesListParams struct {
	// A unique identifier that allows for fetching the next set of audiences
	Cursor *string `json:"-" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (a *AudiencesListParams) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudiencesListParams) SetCursor(cursor *string) {
	a.Cursor = cursor
	a.require(audiencesListParamsFieldCursor)
}

var (
	audienceMembersListParamsFieldCursor = big.NewInt(1 << 0)
)

type AudienceMembersListParams struct {
	// A unique identifier that allows for fetching the next set of members
	Cursor *string `json:"-" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (a *AudienceMembersListParams) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMembersListParams) SetCursor(cursor *string) {
	a.Cursor = cursor
	a.require(audienceMembersListParamsFieldCursor)
}

var (
	audienceFieldId          = big.NewInt(1 << 0)
	audienceFieldName        = big.NewInt(1 << 1)
	audienceFieldDescription = big.NewInt(1 << 2)
	audienceFieldFilter      = big.NewInt(1 << 3)
	audienceFieldCreatedAt   = big.NewInt(1 << 4)
	audienceFieldUpdatedAt   = big.NewInt(1 << 5)
)

type Audience struct {
	// A unique identifier representing the audience_id
	Id string `json:"id" url:"id"`
	// The name of the audience
	Name string `json:"name" url:"name"`
	// A description of the audience
	Description string  `json:"description" url:"description"`
	Filter      *Filter `json:"filter" url:"filter"`
	CreatedAt   string  `json:"created_at" url:"created_at"`
	UpdatedAt   string  `json:"updated_at" url:"updated_at"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Audience) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Audience) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *Audience) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *Audience) GetFilter() *Filter {
	if a == nil {
		return nil
	}
	return a.Filter
}

func (a *Audience) GetCreatedAt() string {
	if a == nil {
		return ""
	}
	return a.CreatedAt
}

func (a *Audience) GetUpdatedAt() string {
	if a == nil {
		return ""
	}
	return a.UpdatedAt
}

func (a *Audience) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Audience) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetId(id string) {
	a.Id = id
	a.require(audienceFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetName(name string) {
	a.Name = name
	a.require(audienceFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetDescription(description string) {
	a.Description = description
	a.require(audienceFieldDescription)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetFilter(filter *Filter) {
	a.Filter = filter
	a.require(audienceFieldFilter)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetCreatedAt(createdAt string) {
	a.CreatedAt = createdAt
	a.require(audienceFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Audience) SetUpdatedAt(updatedAt string) {
	a.UpdatedAt = updatedAt
	a.require(audienceFieldUpdatedAt)
}

func (a *Audience) UnmarshalJSON(data []byte) error {
	type unmarshaler Audience
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Audience(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Audience) MarshalJSON() ([]byte, error) {
	type embed Audience
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Audience) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	audienceListResponseFieldItems  = big.NewInt(1 << 0)
	audienceListResponseFieldPaging = big.NewInt(1 << 1)
)

type AudienceListResponse struct {
	Items  []*Audience `json:"items" url:"items"`
	Paging *Paging     `json:"paging" url:"paging"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AudienceListResponse) GetItems() []*Audience {
	if a == nil {
		return nil
	}
	return a.Items
}

func (a *AudienceListResponse) GetPaging() *Paging {
	if a == nil {
		return nil
	}
	return a.Paging
}

func (a *AudienceListResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudienceListResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceListResponse) SetItems(items []*Audience) {
	a.Items = items
	a.require(audienceListResponseFieldItems)
}

// SetPaging sets the Paging field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceListResponse) SetPaging(paging *Paging) {
	a.Paging = paging
	a.require(audienceListResponseFieldPaging)
}

func (a *AudienceListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceListResponse) MarshalJSON() ([]byte, error) {
	type embed AudienceListResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AudienceListResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	audienceMemberFieldAddedAt         = big.NewInt(1 << 0)
	audienceMemberFieldAudienceId      = big.NewInt(1 << 1)
	audienceMemberFieldAudienceVersion = big.NewInt(1 << 2)
	audienceMemberFieldMemberId        = big.NewInt(1 << 3)
	audienceMemberFieldReason          = big.NewInt(1 << 4)
)

type AudienceMember struct {
	AddedAt         string `json:"added_at" url:"added_at"`
	AudienceId      string `json:"audience_id" url:"audience_id"`
	AudienceVersion int    `json:"audience_version" url:"audience_version"`
	MemberId        string `json:"member_id" url:"member_id"`
	Reason          string `json:"reason" url:"reason"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AudienceMember) GetAddedAt() string {
	if a == nil {
		return ""
	}
	return a.AddedAt
}

func (a *AudienceMember) GetAudienceId() string {
	if a == nil {
		return ""
	}
	return a.AudienceId
}

func (a *AudienceMember) GetAudienceVersion() int {
	if a == nil {
		return 0
	}
	return a.AudienceVersion
}

func (a *AudienceMember) GetMemberId() string {
	if a == nil {
		return ""
	}
	return a.MemberId
}

func (a *AudienceMember) GetReason() string {
	if a == nil {
		return ""
	}
	return a.Reason
}

func (a *AudienceMember) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudienceMember) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAddedAt sets the AddedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMember) SetAddedAt(addedAt string) {
	a.AddedAt = addedAt
	a.require(audienceMemberFieldAddedAt)
}

// SetAudienceId sets the AudienceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMember) SetAudienceId(audienceId string) {
	a.AudienceId = audienceId
	a.require(audienceMemberFieldAudienceId)
}

// SetAudienceVersion sets the AudienceVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMember) SetAudienceVersion(audienceVersion int) {
	a.AudienceVersion = audienceVersion
	a.require(audienceMemberFieldAudienceVersion)
}

// SetMemberId sets the MemberId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMember) SetMemberId(memberId string) {
	a.MemberId = memberId
	a.require(audienceMemberFieldMemberId)
}

// SetReason sets the Reason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMember) SetReason(reason string) {
	a.Reason = reason
	a.require(audienceMemberFieldReason)
}

func (a *AudienceMember) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMember(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMember) MarshalJSON() ([]byte, error) {
	type embed AudienceMember
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AudienceMember) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	audienceMemberGetResponseFieldAudienceMember = big.NewInt(1 << 0)
)

type AudienceMemberGetResponse struct {
	AudienceMember *AudienceMember `json:"audienceMember" url:"audienceMember"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AudienceMemberGetResponse) GetAudienceMember() *AudienceMember {
	if a == nil {
		return nil
	}
	return a.AudienceMember
}

func (a *AudienceMemberGetResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudienceMemberGetResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAudienceMember sets the AudienceMember field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMemberGetResponse) SetAudienceMember(audienceMember *AudienceMember) {
	a.AudienceMember = audienceMember
	a.require(audienceMemberGetResponseFieldAudienceMember)
}

func (a *AudienceMemberGetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMemberGetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMemberGetResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMemberGetResponse) MarshalJSON() ([]byte, error) {
	type embed AudienceMemberGetResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AudienceMemberGetResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	audienceMemberListResponseFieldItems  = big.NewInt(1 << 0)
	audienceMemberListResponseFieldPaging = big.NewInt(1 << 1)
)

type AudienceMemberListResponse struct {
	Items  []*AudienceMember `json:"items" url:"items"`
	Paging *Paging           `json:"paging" url:"paging"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AudienceMemberListResponse) GetItems() []*AudienceMember {
	if a == nil {
		return nil
	}
	return a.Items
}

func (a *AudienceMemberListResponse) GetPaging() *Paging {
	if a == nil {
		return nil
	}
	return a.Paging
}

func (a *AudienceMemberListResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudienceMemberListResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMemberListResponse) SetItems(items []*AudienceMember) {
	a.Items = items
	a.require(audienceMemberListResponseFieldItems)
}

// SetPaging sets the Paging field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceMemberListResponse) SetPaging(paging *Paging) {
	a.Paging = paging
	a.require(audienceMemberListResponseFieldPaging)
}

func (a *AudienceMemberListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceMemberListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceMemberListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceMemberListResponse) MarshalJSON() ([]byte, error) {
	type embed AudienceMemberListResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AudienceMemberListResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	audienceUpdateResponseFieldAudience = big.NewInt(1 << 0)
)

type AudienceUpdateResponse struct {
	Audience *Audience `json:"audience" url:"audience"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AudienceUpdateResponse) GetAudience() *Audience {
	if a == nil {
		return nil
	}
	return a.Audience
}

func (a *AudienceUpdateResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudienceUpdateResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAudience sets the Audience field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceUpdateResponse) SetAudience(audience *Audience) {
	a.Audience = audience
	a.require(audienceUpdateResponseFieldAudience)
}

func (a *AudienceUpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AudienceUpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudienceUpdateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudienceUpdateResponse) MarshalJSON() ([]byte, error) {
	type embed AudienceUpdateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AudienceUpdateResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	baseFilterConfigFieldOperator = big.NewInt(1 << 0)
)

type BaseFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator `json:"operator" url:"operator"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseFilterConfig) GetOperator() *Operator {
	if b == nil {
		return nil
	}
	return b.Operator
}

func (b *BaseFilterConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseFilterConfig) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseFilterConfig) SetOperator(operator *Operator) {
	b.Operator = operator
	b.require(baseFilterConfigFieldOperator)
}

func (b *BaseFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseFilterConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseFilterConfig) MarshalJSON() ([]byte, error) {
	type embed BaseFilterConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseFilterConfig) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ComparisonOperator string

const (
	ComparisonOperatorEndsWith   ComparisonOperator = "ENDS_WITH"
	ComparisonOperatorEq         ComparisonOperator = "EQ"
	ComparisonOperatorExists     ComparisonOperator = "EXISTS"
	ComparisonOperatorGt         ComparisonOperator = "GT"
	ComparisonOperatorGte        ComparisonOperator = "GTE"
	ComparisonOperatorIncludes   ComparisonOperator = "INCLUDES"
	ComparisonOperatorIsAfter    ComparisonOperator = "IS_AFTER"
	ComparisonOperatorIsBefore   ComparisonOperator = "IS_BEFORE"
	ComparisonOperatorLt         ComparisonOperator = "LT"
	ComparisonOperatorLte        ComparisonOperator = "LTE"
	ComparisonOperatorNeq        ComparisonOperator = "NEQ"
	ComparisonOperatorOmit       ComparisonOperator = "OMIT"
	ComparisonOperatorStartsWith ComparisonOperator = "STARTS_WITH"
)

func NewComparisonOperatorFromString(s string) (ComparisonOperator, error) {
	switch s {
	case "ENDS_WITH":
		return ComparisonOperatorEndsWith, nil
	case "EQ":
		return ComparisonOperatorEq, nil
	case "EXISTS":
		return ComparisonOperatorExists, nil
	case "GT":
		return ComparisonOperatorGt, nil
	case "GTE":
		return ComparisonOperatorGte, nil
	case "INCLUDES":
		return ComparisonOperatorIncludes, nil
	case "IS_AFTER":
		return ComparisonOperatorIsAfter, nil
	case "IS_BEFORE":
		return ComparisonOperatorIsBefore, nil
	case "LT":
		return ComparisonOperatorLt, nil
	case "LTE":
		return ComparisonOperatorLte, nil
	case "NEQ":
		return ComparisonOperatorNeq, nil
	case "OMIT":
		return ComparisonOperatorOmit, nil
	case "STARTS_WITH":
		return ComparisonOperatorStartsWith, nil
	}
	var t ComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComparisonOperator) Ptr() *ComparisonOperator {
	return &c
}

type Filter struct {
	SingleFilterConfig *SingleFilterConfig
	NestedFilterConfig *NestedFilterConfig

	typ string
}

func (f *Filter) GetSingleFilterConfig() *SingleFilterConfig {
	if f == nil {
		return nil
	}
	return f.SingleFilterConfig
}

func (f *Filter) GetNestedFilterConfig() *NestedFilterConfig {
	if f == nil {
		return nil
	}
	return f.NestedFilterConfig
}

func (f *Filter) UnmarshalJSON(data []byte) error {
	valueSingleFilterConfig := new(SingleFilterConfig)
	if err := json.Unmarshal(data, &valueSingleFilterConfig); err == nil {
		f.typ = "SingleFilterConfig"
		f.SingleFilterConfig = valueSingleFilterConfig
		return nil
	}
	valueNestedFilterConfig := new(NestedFilterConfig)
	if err := json.Unmarshal(data, &valueNestedFilterConfig); err == nil {
		f.typ = "NestedFilterConfig"
		f.NestedFilterConfig = valueNestedFilterConfig
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f Filter) MarshalJSON() ([]byte, error) {
	if f.typ == "SingleFilterConfig" || f.SingleFilterConfig != nil {
		return json.Marshal(f.SingleFilterConfig)
	}
	if f.typ == "NestedFilterConfig" || f.NestedFilterConfig != nil {
		return json.Marshal(f.NestedFilterConfig)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilterVisitor interface {
	VisitSingleFilterConfig(*SingleFilterConfig) error
	VisitNestedFilterConfig(*NestedFilterConfig) error
}

func (f *Filter) Accept(visitor FilterVisitor) error {
	if f.typ == "SingleFilterConfig" || f.SingleFilterConfig != nil {
		return visitor.VisitSingleFilterConfig(f.SingleFilterConfig)
	}
	if f.typ == "NestedFilterConfig" || f.NestedFilterConfig != nil {
		return visitor.VisitNestedFilterConfig(f.NestedFilterConfig)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilterConfig struct {
	SingleFilterConfig *SingleFilterConfig
	NestedFilterConfig *NestedFilterConfig

	typ string
}

func (f *FilterConfig) GetSingleFilterConfig() *SingleFilterConfig {
	if f == nil {
		return nil
	}
	return f.SingleFilterConfig
}

func (f *FilterConfig) GetNestedFilterConfig() *NestedFilterConfig {
	if f == nil {
		return nil
	}
	return f.NestedFilterConfig
}

func (f *FilterConfig) UnmarshalJSON(data []byte) error {
	valueSingleFilterConfig := new(SingleFilterConfig)
	if err := json.Unmarshal(data, &valueSingleFilterConfig); err == nil {
		f.typ = "SingleFilterConfig"
		f.SingleFilterConfig = valueSingleFilterConfig
		return nil
	}
	valueNestedFilterConfig := new(NestedFilterConfig)
	if err := json.Unmarshal(data, &valueNestedFilterConfig); err == nil {
		f.typ = "NestedFilterConfig"
		f.NestedFilterConfig = valueNestedFilterConfig
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterConfig) MarshalJSON() ([]byte, error) {
	if f.typ == "SingleFilterConfig" || f.SingleFilterConfig != nil {
		return json.Marshal(f.SingleFilterConfig)
	}
	if f.typ == "NestedFilterConfig" || f.NestedFilterConfig != nil {
		return json.Marshal(f.NestedFilterConfig)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilterConfigVisitor interface {
	VisitSingleFilterConfig(*SingleFilterConfig) error
	VisitNestedFilterConfig(*NestedFilterConfig) error
}

func (f *FilterConfig) Accept(visitor FilterConfigVisitor) error {
	if f.typ == "SingleFilterConfig" || f.SingleFilterConfig != nil {
		return visitor.VisitSingleFilterConfig(f.SingleFilterConfig)
	}
	if f.typ == "NestedFilterConfig" || f.NestedFilterConfig != nil {
		return visitor.VisitNestedFilterConfig(f.NestedFilterConfig)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type LogicalOperator string

const (
	LogicalOperatorAnd LogicalOperator = "AND"
	LogicalOperatorOr  LogicalOperator = "OR"
)

func NewLogicalOperatorFromString(s string) (LogicalOperator, error) {
	switch s {
	case "AND":
		return LogicalOperatorAnd, nil
	case "OR":
		return LogicalOperatorOr, nil
	}
	var t LogicalOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogicalOperator) Ptr() *LogicalOperator {
	return &l
}

// The operator to use for filtering
var (
	nestedFilterConfigFieldOperator = big.NewInt(1 << 0)
	nestedFilterConfigFieldRules    = big.NewInt(1 << 1)
)

type NestedFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator       `json:"operator" url:"operator"`
	Rules    []*FilterConfig `json:"rules" url:"rules"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NestedFilterConfig) GetOperator() *Operator {
	if n == nil {
		return nil
	}
	return n.Operator
}

func (n *NestedFilterConfig) GetRules() []*FilterConfig {
	if n == nil {
		return nil
	}
	return n.Rules
}

func (n *NestedFilterConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NestedFilterConfig) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedFilterConfig) SetOperator(operator *Operator) {
	n.Operator = operator
	n.require(nestedFilterConfigFieldOperator)
}

// SetRules sets the Rules field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedFilterConfig) SetRules(rules []*FilterConfig) {
	n.Rules = rules
	n.require(nestedFilterConfigFieldRules)
}

func (n *NestedFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NestedFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NestedFilterConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NestedFilterConfig) MarshalJSON() ([]byte, error) {
	type embed NestedFilterConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NestedFilterConfig) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Operator struct {
	ComparisonOperator ComparisonOperator
	LogicalOperator    LogicalOperator

	typ string
}

func (o *Operator) GetComparisonOperator() ComparisonOperator {
	if o == nil {
		return ""
	}
	return o.ComparisonOperator
}

func (o *Operator) GetLogicalOperator() LogicalOperator {
	if o == nil {
		return ""
	}
	return o.LogicalOperator
}

func (o *Operator) UnmarshalJSON(data []byte) error {
	var valueComparisonOperator ComparisonOperator
	if err := json.Unmarshal(data, &valueComparisonOperator); err == nil {
		o.typ = "ComparisonOperator"
		o.ComparisonOperator = valueComparisonOperator
		return nil
	}
	var valueLogicalOperator LogicalOperator
	if err := json.Unmarshal(data, &valueLogicalOperator); err == nil {
		o.typ = "LogicalOperator"
		o.LogicalOperator = valueLogicalOperator
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o Operator) MarshalJSON() ([]byte, error) {
	if o.typ == "ComparisonOperator" || o.ComparisonOperator != "" {
		return json.Marshal(o.ComparisonOperator)
	}
	if o.typ == "LogicalOperator" || o.LogicalOperator != "" {
		return json.Marshal(o.LogicalOperator)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OperatorVisitor interface {
	VisitComparisonOperator(ComparisonOperator) error
	VisitLogicalOperator(LogicalOperator) error
}

func (o *Operator) Accept(visitor OperatorVisitor) error {
	if o.typ == "ComparisonOperator" || o.ComparisonOperator != "" {
		return visitor.VisitComparisonOperator(o.ComparisonOperator)
	}
	if o.typ == "LogicalOperator" || o.LogicalOperator != "" {
		return visitor.VisitLogicalOperator(o.LogicalOperator)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

// A single filter to use for filtering
var (
	singleFilterConfigFieldOperator = big.NewInt(1 << 0)
	singleFilterConfigFieldValue    = big.NewInt(1 << 1)
	singleFilterConfigFieldPath     = big.NewInt(1 << 2)
)

type SingleFilterConfig struct {
	// The operator to use for filtering
	Operator *Operator `json:"operator" url:"operator"`
	// The value to use for filtering
	Value string `json:"value" url:"value"`
	// The attribe name from profile whose value will be operated against the filter value
	Path string `json:"path" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleFilterConfig) GetOperator() *Operator {
	if s == nil {
		return nil
	}
	return s.Operator
}

func (s *SingleFilterConfig) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

func (s *SingleFilterConfig) GetPath() string {
	if s == nil {
		return ""
	}
	return s.Path
}

func (s *SingleFilterConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleFilterConfig) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterConfig) SetOperator(operator *Operator) {
	s.Operator = operator
	s.require(singleFilterConfigFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterConfig) SetValue(value string) {
	s.Value = value
	s.require(singleFilterConfigFieldValue)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterConfig) SetPath(path string) {
	s.Path = path
	s.require(singleFilterConfigFieldPath)
}

func (s *SingleFilterConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleFilterConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleFilterConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleFilterConfig) MarshalJSON() ([]byte, error) {
	type embed SingleFilterConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleFilterConfig) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	audienceUpdateParamsFieldName        = big.NewInt(1 << 0)
	audienceUpdateParamsFieldDescription = big.NewInt(1 << 1)
	audienceUpdateParamsFieldFilter      = big.NewInt(1 << 2)
)

type AudienceUpdateParams struct {
	// The name of the audience
	Name *string `json:"name,omitempty" url:"-"`
	// A description of the audience
	Description *string `json:"description,omitempty" url:"-"`
	Filter      *Filter `json:"filter,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (a *AudienceUpdateParams) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceUpdateParams) SetName(name *string) {
	a.Name = name
	a.require(audienceUpdateParamsFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceUpdateParams) SetDescription(description *string) {
	a.Description = description
	a.require(audienceUpdateParamsFieldDescription)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudienceUpdateParams) SetFilter(filter *Filter) {
	a.Filter = filter
	a.require(audienceUpdateParamsFieldFilter)
}
